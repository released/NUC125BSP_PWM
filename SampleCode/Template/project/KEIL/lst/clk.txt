; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;33     }
00000a  4770              BX       lr
;;;34     
                          ENDP

                  |L1.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;517      */
;;;518    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;519    {
;;;520        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4909              LDR      r1,|L2.40|
000004  c90e              LDM      r1,{r1-r3}
;;;521    
;;;522        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L2.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4382              BICS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;523    }
000026  bd0e              POP      {r1-r3,pc}
;;;524    
                          ENDP

                  |L2.40|
                          DCD      ||.constdata||+0x1c
                  |L2.44|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;664      */
;;;665    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;666    {
;;;667        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a01              LDR      r1,[r0,#0x20]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;668    }
00000a  4770              BX       lr
;;;669    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;735      */
;;;736    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L4.8|
;;;737    {
;;;738        /* Set System Tick counter disabled */
;;;739        SysTick->CTRL = 0;
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;740    }
000006  4770              BX       lr
;;;741    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;441      */
;;;442    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;443    {
;;;444        CLK->PWRCTL &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;445    }
000008  4770              BX       lr
;;;446    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;54       */
;;;55     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  0152              LSLS     r2,r2,#5
;;;56     {
;;;57         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;58         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  430a              ORRS     r2,r2,r1
000004  2110              MOVS     r1,#0x10
000006  430a              ORRS     r2,r2,r1
000008  4905              LDR      r1,|L6.32|
00000a  624a              STR      r2,[r1,#0x24]
;;;59     
;;;60         /* Enable CKO clock source */
;;;61         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000c  688a              LDR      r2,[r1,#8]
00000e  2340              MOVS     r3,#0x40
000010  431a              ORRS     r2,r2,r3
000012  608a              STR      r2,[r1,#8]
;;;62     
;;;63         /* Select CKO clock source */
;;;64         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | (u32ClkSrc);
000014  69ca              LDR      r2,[r1,#0x1c]
000016  231c              MOVS     r3,#0x1c
000018  439a              BICS     r2,r2,r3
00001a  4302              ORRS     r2,r2,r0
00001c  61ca              STR      r2,[r1,#0x1c]
;;;65     
;;;66     }
00001e  4770              BX       lr
;;;67     
                          ENDP

                  |L6.32|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;478      */
;;;479    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;480    {
;;;481        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4909              LDR      r1,|L7.40|
000004  c90e              LDM      r1,{r1-r3}
;;;482    
;;;483        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L7.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4302              ORRS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;484    }
000026  bd0e              POP      {r1-r3,pc}
;;;485    
                          ENDP

                  |L7.40|
                          DCD      ||.constdata||+0x10
                  |L7.44|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;536      */
;;;537    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;538    {
000002  b085              SUB      sp,sp,#0x14
000004  460c              MOV      r4,r1
000006  4607              MOV      r7,r0
;;;539        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;540        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;541    
;;;542        /* Disable PLL first to avoid unstable when setting PLL */
;;;543        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;544    
;;;545        /* PLL source clock is from HXT */
;;;546        if (u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;547        {
;;;548            /* Enable HXT clock */
;;;549            CLK->PWRCTL = (CLK->PWRCTL & ~CLK_PWRCTL_XTLEN_Msk) | CLK_PWRCTL_HXTEN;
;;;550    
;;;551            /* Wait for HXT clock ready */
;;;552            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;553    
;;;554            /* Select PLL source clock from HXT */
;;;555            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;556            u32PllSrcClk = __HXT;
;;;557    
;;;558            /* u32NR start from 2 */
;;;559            u32NR = 2;
;;;560        }
;;;561    
;;;562        /* PLL source clock is from HIRC_DIV2 */
;;;563        else
;;;564        {
;;;565            /* Enable HIRC_DIV2 clock */
;;;566            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  4855              LDR      r0,|L8.356|
00000e  4e54              LDR      r6,|L8.352|
000010  6801              LDR      r1,[r0,#0]
000012  2f00              CMP      r7,#0                 ;546
000014  d013              BEQ      |L8.62|
000016  2204              MOVS     r2,#4
000018  4311              ORRS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;567    
;;;568            /* Wait for HIRC clock ready */
;;;569            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;570    
;;;571            /* Select PLL source clock from HIRC */
;;;572            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC_DIV2;
000022  2011              MOVS     r0,#0x11
000024  04c0              LSLS     r0,r0,#19
;;;573            u32PllSrcClk = __HIRC_DIV2;
000026  9002              STR      r0,[sp,#8]
000028  0070              LSLS     r0,r6,#1
;;;574    
;;;575            /* u32NR start from 4 when FIN = 24MHz to avoid calculation overflow */
;;;576            u32NR = 4;
00002a  2504              MOVS     r5,#4
00002c  9003              STR      r0,[sp,#0xc]
                  |L8.46|
;;;577        }
;;;578    
;;;579        /* Select "NO" according to request frequency */
;;;580        if ((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq > FREQ_250MHZ))
00002e  484e              LDR      r0,|L8.360|
000030  494e              LDR      r1,|L8.364|
000032  1820              ADDS     r0,r4,r0
000034  4288              CMP      r0,r1
000036  d80e              BHI      |L8.86|
;;;581        {
;;;582            u32NO = 0;
000038  2000              MOVS     r0,#0
00003a  9004              STR      r0,[sp,#0x10]
00003c  e01c              B        |L8.120|
                  |L8.62|
00003e  0889              LSRS     r1,r1,#2              ;549
000040  0089              LSLS     r1,r1,#2              ;549
000042  1c49              ADDS     r1,r1,#1              ;549
000044  6001              STR      r1,[r0,#0]            ;549
000046  2001              MOVS     r0,#1                 ;552
000048  f7fffffe          BL       CLK_WaitClockReady
00004c  2000              MOVS     r0,#0                 ;555
00004e  2502              MOVS     r5,#2                 ;559
000050  9603              STR      r6,[sp,#0xc]          ;559
000052  9002              STR      r0,[sp,#8]            ;559
000054  e7eb              B        |L8.46|
                  |L8.86|
;;;583        }
;;;584        else if ((u32PllFreq <= FREQ_250MHZ) && (u32PllFreq > FREQ_125MHZ))
000056  4846              LDR      r0,|L8.368|
000058  4946              LDR      r1,|L8.372|
00005a  1820              ADDS     r0,r4,r0
00005c  4288              CMP      r0,r1
00005e  d803              BHI      |L8.104|
;;;585        {
;;;586            u32NO = 1;
000060  2001              MOVS     r0,#1
;;;587            u32PllFreq = u32PllFreq << 1;
000062  0064              LSLS     r4,r4,#1
000064  9004              STR      r0,[sp,#0x10]
000066  e007              B        |L8.120|
                  |L8.104|
;;;588        }
;;;589        else if ((u32PllFreq <= FREQ_125MHZ) && (u32PllFreq >= FREQ_50MHZ))
000068  4843              LDR      r0,|L8.376|
00006a  4944              LDR      r1,|L8.380|
00006c  1820              ADDS     r0,r4,r0
00006e  4288              CMP      r0,r1
000070  d848              BHI      |L8.260|
;;;590        {
;;;591            u32NO = 3;
000072  2003              MOVS     r0,#3
;;;592            u32PllFreq = u32PllFreq << 2;
000074  00a4              LSLS     r4,r4,#2
000076  9004              STR      r0,[sp,#0x10]
                  |L8.120|
;;;593        }
;;;594        else
;;;595        {
;;;596            /* Wrong frequency request. Just return default setting. */
;;;597            goto lexit;
;;;598        }
;;;599    
;;;600        /* Find best solution */
;;;601        u32Min = (uint32_t) - 1;
000078  2600              MOVS     r6,#0
00007a  43f6              MVNS     r6,r6
;;;602        u32MinNR = 0;
00007c  2000              MOVS     r0,#0
;;;603        u32MinNF = 0;
00007e  9000              STR      r0,[sp,#0]
;;;604    
;;;605        for (; u32NR <= 33; u32NR++)
000080  9001              STR      r0,[sp,#4]
000082  e020              B        |L8.198|
                  |L8.132|
;;;606        {
;;;607            u32Tmp = u32PllSrcClk / u32NR;
000084  4629              MOV      r1,r5
000086  9803              LDR      r0,[sp,#0xc]
000088  f7fffffe          BL       __aeabi_uidivmod
;;;608    
;;;609            if ((u32Tmp > 1600000) && (u32Tmp < 16000000))
00008c  493c              LDR      r1,|L8.384|
00008e  4a3d              LDR      r2,|L8.388|
000090  1841              ADDS     r1,r0,r1
000092  4291              CMP      r1,r2
000094  d216              BCS      |L8.196|
;;;610            {
;;;611                for (u32NF = 2; u32NF <= 513; u32NF++)
000096  2202              MOVS     r2,#2
                  |L8.152|
000098  4601              MOV      r1,r0
;;;612                {
;;;613                    u32Tmp2 = u32Tmp * u32NF;
;;;614    
;;;615                    if ((u32Tmp2 >= 200000000) && (u32Tmp2 <= 500000000))
00009a  4b3b              LDR      r3,|L8.392|
00009c  4351              MULS     r1,r2,r1              ;613
00009e  18cf              ADDS     r7,r1,r3
0000a0  4b3a              LDR      r3,|L8.396|
0000a2  429f              CMP      r7,r3
0000a4  d80a              BHI      |L8.188|
;;;616                    {
;;;617                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000a6  42a1              CMP      r1,r4
0000a8  d901              BLS      |L8.174|
0000aa  1b0b              SUBS     r3,r1,r4
0000ac  e000              B        |L8.176|
                  |L8.174|
0000ae  1a63              SUBS     r3,r4,r1
                  |L8.176|
;;;618    
;;;619                        if (u32Tmp3 < u32Min)
0000b0  42b3              CMP      r3,r6
0000b2  d203              BCS      |L8.188|
;;;620                        {
;;;621                            u32Min = u32Tmp3;
0000b4  001e              MOVS     r6,r3
;;;622                            u32MinNR = u32NR;
;;;623                            u32MinNF = u32NF;
;;;624    
;;;625                            /* Break when get good results */
;;;626                            if (u32Min == 0)
0000b6  9500              STR      r5,[sp,#0]
0000b8  9201              STR      r2,[sp,#4]
0000ba  d003              BEQ      |L8.196|
                  |L8.188|
0000bc  4934              LDR      r1,|L8.400|
0000be  1c52              ADDS     r2,r2,#1              ;611
0000c0  428a              CMP      r2,r1                 ;611
0000c2  d9e9              BLS      |L8.152|
                  |L8.196|
0000c4  1c6d              ADDS     r5,r5,#1              ;611
                  |L8.198|
0000c6  2d21              CMP      r5,#0x21              ;605
0000c8  d9dc              BLS      |L8.132|
;;;627                                break;
;;;628                        }
;;;629                    }
;;;630                }
;;;631            }
;;;632        }
;;;633    
;;;634        /* Enable and apply new PLL setting. */
;;;635        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
0000ca  9804              LDR      r0,[sp,#0x10]
0000cc  9902              LDR      r1,[sp,#8]
0000ce  0380              LSLS     r0,r0,#14
0000d0  4308              ORRS     r0,r0,r1
0000d2  9900              LDR      r1,[sp,#0]
0000d4  2201              MOVS     r2,#1
0000d6  0249              LSLS     r1,r1,#9
0000d8  0292              LSLS     r2,r2,#10
0000da  1a89              SUBS     r1,r1,r2
0000dc  4308              ORRS     r0,r0,r1
0000de  9901              LDR      r1,[sp,#4]
0000e0  1e89              SUBS     r1,r1,#2
0000e2  4308              ORRS     r0,r0,r1
0000e4  491f              LDR      r1,|L8.356|
0000e6  6208              STR      r0,[r1,#0x20]
;;;636    
;;;637        /* Wait for PLL clock stable */
;;;638        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000e8  2004              MOVS     r0,#4
0000ea  f7fffffe          BL       CLK_WaitClockReady
;;;639    
;;;640        /* Return actual PLL output clock frequency */
;;;641        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
0000ee  9904              LDR      r1,[sp,#0x10]
0000f0  9800              LDR      r0,[sp,#0]
0000f2  1c49              ADDS     r1,r1,#1
0000f4  4341              MULS     r1,r0,r1
0000f6  9803              LDR      r0,[sp,#0xc]
0000f8  f7fffffe          BL       __aeabi_uidivmod
0000fc  9901              LDR      r1,[sp,#4]
0000fe  4348              MULS     r0,r1,r0
                  |L8.256|
;;;642    
;;;643    lexit:
;;;644    
;;;645        /* Apply default PLL setting and return */
;;;646        if (u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;647            CLK->PLLCTL = CLK_PLLCTL_96MHz_HXT; /* 96MHz */
;;;648        else
;;;649            CLK->PLLCTL = CLK_PLLCTL_96MHz_HIRC_DIV2; /* 96MHz */
;;;650    
;;;651        /* Wait for PLL clock stable */
;;;652        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;653    
;;;654        return CLK_GetPLLClockFreq();
;;;655    
;;;656    }
000100  b005              ADD      sp,sp,#0x14
000102  bdf0              POP      {r4-r7,pc}
                  |L8.260|
000104  2f00              CMP      r7,#0                 ;646
000106  d00f              BEQ      |L8.296|
000108  4922              LDR      r1,|L8.404|
                  |L8.266|
00010a  4816              LDR      r0,|L8.356|
00010c  6201              STR      r1,[r0,#0x20]         ;649
00010e  2004              MOVS     r0,#4                 ;652
000110  f7fffffe          BL       CLK_WaitClockReady
000114  a020              ADR      r0,|L8.408|
000116  6800              LDR      r0,[r0,#0]            ;652
000118  9000              STR      r0,[sp,#0]            ;652
00011a  4812              LDR      r0,|L8.356|
00011c  6a01              LDR      r1,[r0,#0x20]         ;652
00011e  1300              ASRS     r0,r0,#12             ;652
000120  4201              TST      r1,r0                 ;652
000122  d003              BEQ      |L8.300|
000124  2000              MOVS     r0,#0                 ;652
000126  e7eb              B        |L8.256|
                  |L8.296|
000128  491c              LDR      r1,|L8.412|
00012a  e7ee              B        |L8.266|
                  |L8.300|
00012c  2011              MOVS     r0,#0x11              ;647
00012e  04c0              LSLS     r0,r0,#19             ;647
000130  4201              TST      r1,r0                 ;647
000132  d000              BEQ      |L8.310|
000134  4e1a              LDR      r6,|L8.416|
                  |L8.310|
000136  0388              LSLS     r0,r1,#14             ;647
000138  d501              BPL      |L8.318|
00013a  4630              MOV      r0,r6                 ;647
00013c  e7e0              B        |L8.256|
                  |L8.318|
00013e  0408              LSLS     r0,r1,#16
000140  0f80              LSRS     r0,r0,#30
000142  466a              MOV      r2,sp
000144  5c10              LDRB     r0,[r2,r0]
000146  05ca              LSLS     r2,r1,#23
000148  0489              LSLS     r1,r1,#18
00014a  0ec9              LSRS     r1,r1,#27
00014c  1c89              ADDS     r1,r1,#2
00014e  0dd2              LSRS     r2,r2,#23
000150  4341              MULS     r1,r0,r1
000152  08b0              LSRS     r0,r6,#2
000154  1c92              ADDS     r2,r2,#2
000156  4350              MULS     r0,r2,r0
000158  f7fffffe          BL       __aeabi_uidivmod
00015c  0080              LSLS     r0,r0,#2
00015e  e7cf              B        |L8.256|
;;;657    
                          ENDP

                  |L8.352|
                          DCD      0x00b71b00
                  |L8.356|
                          DCD      0x50000200
                  |L8.360|
                          DCD      0xf1194d7f
                  |L8.364|
                          DCD      0x0ee6b27f
                  |L8.368|
                          DCD      0xf88ca6bf
                  |L8.372|
                          DCD      0x0773593f
                  |L8.376|
                          DCD      0xfd050f80
                  |L8.380|
                          DCD      0x047868c0
                  |L8.384|
                          DCD      0xffe795ff
                  |L8.388|
                          DCD      0x00dbb9ff
                  |L8.392|
                          DCD      0xf4143e00
                  |L8.396|
                          DCD      0x11e1a300
                  |L8.400|
                          DCD      0x00000201
                  |L8.404|
                          DCD      0x0088c22e
                  |L8.408|
000198  01020204          DCB      1,2,2,4
                  |L8.412|
                          DCD      0x0000c25e
                  |L8.416|
                          DCD      0x016e3600

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;708      */
;;;709    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b570              PUSH     {r4-r6,lr}
;;;710    {
;;;711        /* Set System Tick counter disabled */
;;;712        SysTick->CTRL = 0;
000002  4a0b              LDR      r2,|L9.48|
000004  2400              MOVS     r4,#0
000006  6114              STR      r4,[r2,#0x10]
;;;713    
;;;714        /* Set System Tick clock source */
;;;715        if (u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000008  2804              CMP      r0,#4
00000a  d00c              BEQ      |L9.38|
;;;716            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;717        else
;;;718            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000c  4d09              LDR      r5,|L9.52|
00000e  692b              LDR      r3,[r5,#0x10]
000010  2638              MOVS     r6,#0x38
000012  43b3              BICS     r3,r3,r6
000014  4303              ORRS     r3,r3,r0
000016  612b              STR      r3,[r5,#0x10]
                  |L9.24|
;;;719    
;;;720        /* Set System Tick reload value */
;;;721        SysTick->LOAD = u32Count;
000018  6151              STR      r1,[r2,#0x14]
;;;722    
;;;723        /* Clear System Tick current value and counter flag */
;;;724        SysTick->VAL = 0;
00001a  6194              STR      r4,[r2,#0x18]
;;;725    
;;;726        /* Set System Tick interrupt enabled and counter enabled */
;;;727        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
00001c  6910              LDR      r0,[r2,#0x10]
00001e  2103              MOVS     r1,#3
000020  4308              ORRS     r0,r0,r1
000022  6110              STR      r0,[r2,#0x10]
;;;728    }
000024  bd70              POP      {r4-r6,pc}
                  |L9.38|
000026  6910              LDR      r0,[r2,#0x10]         ;716
000028  2304              MOVS     r3,#4                 ;716
00002a  4318              ORRS     r0,r0,r3              ;716
00002c  6110              STR      r0,[r2,#0x10]         ;716
00002e  e7f3              B        |L9.24|
;;;729    
                          ENDP

                  |L9.48|
                          DCD      0xe000e000
                  |L9.52|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;422      */
;;;423    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4904              LDR      r1,|L10.20|
;;;424    {
;;;425        if (((CLK->PWRCTL | u32ClkMask) & CLK_PWRCTL_XTLEN_Msk) == CLK_PWRCTL_XTLEN_Msk)
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  43d2              MVNS     r2,r2
000008  0792              LSLS     r2,r2,#30
00000a  d002              BEQ      |L10.18|
;;;426            return;
;;;427    
;;;428        CLK->PWRCTL |= u32ClkMask;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
                  |L10.18|
;;;429    }
000012  4770              BX       lr
;;;430    
                          ENDP

                  |L10.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;195      */
;;;196    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;199        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;200    }
00000a  bd10              POP      {r4,pc}
;;;201    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;151      */
;;;152    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;155        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;156    }
00000a  bd10              POP      {r4,pc}
;;;157    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;122      */
;;;123    uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;124    {
;;;125        if (CLK->PWRCTL & CLK_PWRCTL_HXTEN)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;126            return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;127        else
;;;128            return 0;
;;;129    }
00000a  4770              BX       lr
;;;130    
                          ENDP

                  |L13.12|
                          DCD      0x50000200
                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;136      */
;;;137    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;138    {
;;;139        if (CLK->PWRCTL & CLK_PWRCTL_LXTEN)
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L14.14|
;;;140            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;141        else
;;;142            return 0;
;;;143    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;142
000010  4770              BX       lr
;;;144    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;163      */
;;;164    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;167    
;;;168        if (CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000006  4804              LDR      r0,|L15.24|
000008  6900              LDR      r0,[r0,#0x10]
00000a  0641              LSLS     r1,r0,#25
;;;169            return SystemCoreClock >> 1;
00000c  4803              LDR      r0,|L15.28|
;;;170        else
;;;171            return SystemCoreClock;
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  d500              BPL      |L15.20|
000012  0840              LSRS     r0,r0,#1              ;169
                  |L15.20|
;;;172    }
000014  bd10              POP      {r4,pc}
;;;173    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x50000200
                  |L15.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;179      */
;;;180    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;181    {
;;;182        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;183    
;;;184        if (CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000006  4804              LDR      r0,|L16.24|
000008  6900              LDR      r0,[r0,#0x10]
00000a  0601              LSLS     r1,r0,#24
;;;185            return SystemCoreClock >> 1;
00000c  4803              LDR      r0,|L16.28|
;;;186        else
;;;187            return SystemCoreClock;
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  d500              BPL      |L16.20|
000012  0840              LSRS     r0,r0,#1              ;185
                  |L16.20|
;;;188    }
000014  bd10              POP      {r4,pc}
;;;189    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x50000200
                  |L16.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;104      */
;;;105    void CLK_Idle(void)
000000  4805              LDR      r0,|L17.24|
;;;106    {
;;;107        /* Set the processor uses sleep as its low power mode */
;;;108        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;109    
;;;110        /* Set chip in idle mode because of WFI command */
;;;111        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  4804              LDR      r0,|L17.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4391              BICS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;112    
;;;113        /* Chip enter idle mode after CPU run WFI instruction */
;;;114        __WFI();
000014  bf30              WFI      
;;;115    }
000016  4770              BX       lr
;;;116    
                          ENDP

                  |L17.24|
                          DCD      0xe000ed00
                  |L17.28|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;74       */
;;;75     void CLK_PowerDown(void)
000000  4809              LDR      r0,|L18.40|
;;;76     {
;;;77         uint32_t u32HIRCTRIMCTL;
;;;78     
;;;79         /* Set the processor uses deep sleep as its low power mode */
;;;80         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;81     
;;;82         /* Set system Power-down enabled */
;;;83         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000a  4808              LDR      r0,|L18.44|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;84     
;;;85         /* Store HIRC control register */
;;;86         u32HIRCTRIMCTL = SYS->IRCTCTL;
000014  4806              LDR      r0,|L18.48|
000016  6801              LDR      r1,[r0,#0]
;;;87     
;;;88         /* Disable HIRC auto trim */
;;;89         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
000018  6802              LDR      r2,[r0,#0]
00001a  0892              LSRS     r2,r2,#2
00001c  0092              LSLS     r2,r2,#2
00001e  6002              STR      r2,[r0,#0]
;;;90     
;;;91         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;92         __WFI();
000020  bf30              WFI      
;;;93     
;;;94         /* Restore HIRC control register */
;;;95         SYS->IRCTCTL = u32HIRCTRIMCTL;
000022  6001              STR      r1,[r0,#0]
;;;96     }
000024  4770              BX       lr
;;;97     
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      0xe000ed00
                  |L18.44|
                          DCD      0x50000200
                  |L18.48|
                          DCD      0x50000080

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;210      */
;;;211    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;212    {
;;;213        uint32_t u32HIRCSTB;
;;;214    
;;;215        /* Read HIRC clock source stable flag */
;;;216        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4d1c              LDR      r5,|L19.116|
000004  4604              MOV      r4,r0                 ;212
000006  68ee              LDR      r6,[r5,#0xc]
000008  2010              MOVS     r0,#0x10
00000a  4006              ANDS     r6,r6,r0
;;;217    
;;;218        /* The range of u32Hclk is 25 MHz ~ 50 MHz */
;;;219        if (u32Hclk > FREQ_50MHZ)
00000c  481a              LDR      r0,|L19.120|
00000e  4284              CMP      r4,r0
000010  d802              BHI      |L19.24|
;;;220            u32Hclk = FREQ_50MHZ;
;;;221    
;;;222        if (u32Hclk < FREQ_25MHZ)
000012  1040              ASRS     r0,r0,#1
000014  4284              CMP      r4,r0
000016  d200              BCS      |L19.26|
                  |L19.24|
000018  4604              MOV      r4,r0                 ;220
                  |L19.26|
;;;223            u32Hclk = FREQ_25MHZ;
;;;224    
;;;225        /* Switch HCLK clock source to HIRC clock for safe */
;;;226        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001a  6828              LDR      r0,[r5,#0]
00001c  2704              MOVS     r7,#4
00001e  4338              ORRS     r0,r0,r7
000020  6028              STR      r0,[r5,#0]
;;;227        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000022  2010              MOVS     r0,#0x10
000024  f7fffffe          BL       CLK_WaitClockReady
;;;228        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000028  6928              LDR      r0,[r5,#0x10]
00002a  2107              MOVS     r1,#7
00002c  4308              ORRS     r0,r0,r1
00002e  6128              STR      r0,[r5,#0x10]
;;;229        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000030  69a8              LDR      r0,[r5,#0x18]
000032  0900              LSRS     r0,r0,#4
000034  0100              LSLS     r0,r0,#4
000036  61a8              STR      r0,[r5,#0x18]
;;;230    
;;;231        /* Configure PLL setting if HXT clock is stable */
;;;232        if (CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
000038  68e8              LDR      r0,[r5,#0xc]
00003a  07c0              LSLS     r0,r0,#31
00003c  d005              BEQ      |L19.74|
;;;233            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
00003e  0061              LSLS     r1,r4,#1
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       CLK_EnablePLL
000046  4604              MOV      r4,r0
000048  e008              B        |L19.92|
                  |L19.74|
;;;234    
;;;235        /* Configure PLL setting if HXT clock is not stable */
;;;236        else
;;;237        {
;;;238            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC_DIV2, (u32Hclk << 1));
00004a  2011              MOVS     r0,#0x11
00004c  0061              LSLS     r1,r4,#1
00004e  04c0              LSLS     r0,r0,#19
000050  f7fffffe          BL       CLK_EnablePLL
;;;239    
;;;240            /* Read HIRC clock source stable flag */
;;;241            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000054  68ee              LDR      r6,[r5,#0xc]
000056  4604              MOV      r4,r0                 ;238
000058  2010              MOVS     r0,#0x10
00005a  4006              ANDS     r6,r6,r0
                  |L19.92|
;;;242        }
;;;243    
;;;244        /* Select HCLK clock source to PLL,
;;;245           Select HCLK clock source divider as 2
;;;246           and update system core clock
;;;247        */
;;;248        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
00005c  2101              MOVS     r1,#1
00005e  2002              MOVS     r0,#2
000060  f7fffffe          BL       CLK_SetHCLK
;;;249    
;;;250        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;251        if (u32HIRCSTB == 0)
000064  2e00              CMP      r6,#0
000066  d102              BNE      |L19.110|
;;;252            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000068  6828              LDR      r0,[r5,#0]
00006a  43b8              BICS     r0,r0,r7
00006c  6028              STR      r0,[r5,#0]
                  |L19.110|
;;;253    
;;;254        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;255        return u32Hclk >> 1;
00006e  0860              LSRS     r0,r4,#1
;;;256    }
000070  bdf8              POP      {r3-r7,pc}
;;;257    
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      0x50000200
                  |L19.120|
                          DCD      0x02faf080

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;273      */
;;;274    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;275    {
;;;276        uint32_t u32HIRCSTB;
;;;277    
;;;278        /* Read HIRC clock source stable flag */
;;;279        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4c12              LDR      r4,|L20.76|
000004  b081              SUB      sp,sp,#4              ;275
000006  68e5              LDR      r5,[r4,#0xc]
000008  460f              MOV      r7,r1                 ;275
00000a  2010              MOVS     r0,#0x10
00000c  4005              ANDS     r5,r5,r0
;;;280    
;;;281        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;282        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000e  6820              LDR      r0,[r4,#0]
000010  2604              MOVS     r6,#4
000012  4330              ORRS     r0,r0,r6
000014  6020              STR      r0,[r4,#0]
;;;283        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       CLK_WaitClockReady
;;;284        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  08c0              LSRS     r0,r0,#3
000020  00c0              LSLS     r0,r0,#3
000022  1d00              ADDS     r0,r0,#4
000024  6120              STR      r0,[r4,#0x10]
;;;285    
;;;286        /* Apply new Divider */
;;;287        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000026  69a0              LDR      r0,[r4,#0x18]
000028  0900              LSRS     r0,r0,#4
00002a  0100              LSLS     r0,r0,#4
00002c  4338              ORRS     r0,r0,r7
00002e  61a0              STR      r0,[r4,#0x18]
;;;288    
;;;289        /* Switch HCLK to new HCLK source */
;;;290        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
000030  6920              LDR      r0,[r4,#0x10]
000032  9901              LDR      r1,[sp,#4]
000034  08c0              LSRS     r0,r0,#3
000036  00c0              LSLS     r0,r0,#3
000038  4308              ORRS     r0,r0,r1
00003a  6120              STR      r0,[r4,#0x10]
;;;291    
;;;292        /* Update System Core Clock */
;;;293        SystemCoreClockUpdate();
00003c  f7fffffe          BL       SystemCoreClockUpdate
;;;294    
;;;295        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;296        if (u32HIRCSTB == 0)
000040  2d00              CMP      r5,#0
000042  d102              BNE      |L20.74|
;;;297            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000044  6820              LDR      r0,[r4,#0]
000046  43b0              BICS     r0,r0,r6
000048  6020              STR      r0,[r4,#0]
                  |L20.74|
;;;298    }
00004a  bdfe              POP      {r1-r7,pc}
;;;299    /**
                          ENDP

                  |L20.76|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;366      */
;;;367    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;368    {
;;;369        uint32_t u32sel = 0, u32div = 0;
;;;370        uint32_t u32SelTbl[] = {0x0, 0x4, 0xC, 0x24};
000002  4b18              LDR      r3,|L21.100|
000004  b085              SUB      sp,sp,#0x14           ;368
000006  cb78              LDM      r3,{r3-r6}
;;;371        uint32_t u32DivTbl[] = {0x0};
000008  9603              STR      r6,[sp,#0xc]
00000a  466e              MOV      r6,sp
00000c  c638              STM      r6!,{r3-r5}
00000e  2300              MOVS     r3,#0
;;;372    
;;;373        if (MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000010  0a84              LSRS     r4,r0,#10
000012  9304              STR      r3,[sp,#0x10]
000014  0623              LSLS     r3,r4,#24
000016  0e1b              LSRS     r3,r3,#24
000018  d00e              BEQ      |L21.56|
;;;374        {
;;;375            /* Get clock divider control register address */
;;;376            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
00001a  0303              LSLS     r3,r0,#12
00001c  0f9b              LSRS     r3,r3,#30
00001e  009b              LSLS     r3,r3,#2
000020  ad04              ADD      r5,sp,#0x10
000022  58eb              LDR      r3,[r5,r3]
000024  4d10              LDR      r5,|L21.104|
000026  195b              ADDS     r3,r3,r5
;;;377            /* Apply new divider */
;;;378            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000028  b2e5              UXTB     r5,r4
00002a  0584              LSLS     r4,r0,#22
00002c  0ee4              LSRS     r4,r4,#27
00002e  40a5              LSLS     r5,r5,r4
000030  681c              LDR      r4,[r3,#0]
000032  43ac              BICS     r4,r4,r5
000034  4314              ORRS     r4,r4,r2
000036  601c              STR      r4,[r3,#0]
                  |L21.56|
;;;379        }
;;;380    
;;;381        if (MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000038  0e42              LSRS     r2,r0,#25
00003a  0752              LSLS     r2,r2,#29
00003c  d010              BEQ      |L21.96|
;;;382        {
;;;383            /* Get clock select control register address */
;;;384            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
00003e  0082              LSLS     r2,r0,#2
000040  0f92              LSRS     r2,r2,#30
000042  0092              LSLS     r2,r2,#2
000044  466b              MOV      r3,sp
000046  589a              LDR      r2,[r3,r2]
000048  4b07              LDR      r3,|L21.104|
00004a  3b08              SUBS     r3,r3,#8
00004c  18d2              ADDS     r2,r2,r3
;;;385            /* Set new clock selection setting */
;;;386            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
00004e  0103              LSLS     r3,r0,#4
000050  0f5b              LSRS     r3,r3,#29
000052  01c0              LSLS     r0,r0,#7
000054  0ec0              LSRS     r0,r0,#27
000056  4083              LSLS     r3,r3,r0
000058  6810              LDR      r0,[r2,#0]
00005a  4398              BICS     r0,r0,r3
00005c  4308              ORRS     r0,r0,r1
00005e  6010              STR      r0,[r2,#0]
                  |L21.96|
;;;387        }
;;;388    }
000060  b005              ADD      sp,sp,#0x14
000062  bd70              POP      {r4-r6,pc}
;;;389    
                          ENDP

                  |L21.100|
                          DCD      ||.constdata||
                  |L21.104|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;401      */
;;;402    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L22.16|
;;;403    {
;;;404        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;405    }
00000c  4770              BX       lr
;;;406    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;681      */
;;;682    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;683    {
000002  4604              MOV      r4,r0
;;;684        int32_t i32TimeOutCnt = 2160000;
000004  4907              LDR      r1,|L23.36|
;;;685    
;;;686        while ((CLK->STATUS & u32ClkMask) != u32ClkMask)
000006  4b08              LDR      r3,|L23.40|
000008  e005              B        |L23.22|
                  |L23.10|
;;;687        {
;;;688            if (i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L23.22|
;;;689                return 0;
000012  2000              MOVS     r0,#0
;;;690        }
;;;691    
;;;692        return 1;
;;;693    }
000014  bd10              POP      {r4,pc}
                  |L23.22|
000016  68da              LDR      r2,[r3,#0xc]          ;686
000018  4620              MOV      r0,r4                 ;686
00001a  4390              BICS     r0,r0,r2              ;686
00001c  d1f5              BNE      |L23.10|
00001e  2001              MOVS     r0,#1                 ;692
000020  bd10              POP      {r4,pc}
;;;694    
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      0x0020f580
                  |L23.40|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000024
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 479
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
