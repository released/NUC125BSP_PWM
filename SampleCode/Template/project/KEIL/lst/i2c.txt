; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;88       */
;;;89     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;90     {
;;;91         i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;92     }
000008  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;60     
;;;61     void I2C_Close(I2C_T *i2c)
000000  4a0b              LDR      r2,|L2.48|
;;;62     {
;;;63         /* Reset I2C controller */
;;;64         if ((uint32_t)i2c == I2C0_BASE)
;;;65         {
;;;66             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;64
000008  d102              BNE      |L2.16|
00000a  68cb              LDR      r3,[r1,#0xc]
00000c  1582              ASRS     r2,r0,#22
;;;67             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00000e  e004              B        |L2.26|
                  |L2.16|
;;;68         }
;;;69         else if ((uint32_t)i2c == I2C1_BASE)
000010  4a08              LDR      r2,|L2.52|
000012  4290              CMP      r0,r2
000014  d106              BNE      |L2.36|
;;;70         {
;;;71             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000016  68cb              LDR      r3,[r1,#0xc]
000018  1542              ASRS     r2,r0,#21
                  |L2.26|
00001a  4313              ORRS     r3,r3,r2
00001c  60cb              STR      r3,[r1,#0xc]
;;;72             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00001e  68cb              LDR      r3,[r1,#0xc]
000020  4393              BICS     r3,r3,r2
000022  60cb              STR      r3,[r1,#0xc]
                  |L2.36|
;;;73         }
;;;74     
;;;75         /* Disable I2C */
;;;76         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
000024  6801              LDR      r1,[r0,#0]
000026  2240              MOVS     r2,#0x40
000028  4391              BICS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
;;;77     }
00002c  4770              BX       lr
;;;78     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40020000
                  |L2.52|
                          DCD      0x40120000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;136      */
;;;137    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;138    {
;;;139        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;140    }
000008  4770              BX       lr
;;;141    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;353     */
;;;354    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;355    {
;;;356        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;357    }
000008  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;383     */
;;;384    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;385    {
;;;386        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;387    }
000008  4770              BX       lr
;;;388    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;151      */
;;;152    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;153    {
;;;154        i2c->CTL |= I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;155    }
000008  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;333     */
;;;334    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;335    {
;;;336        if (u8LongTimeout)
000002  2900              CMP      r1,#0
;;;337            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;338        else
;;;339            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;337
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;340    
;;;341        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;342    }
000018  4770              BX       lr
;;;343    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;368     */
;;;369    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;370    {
;;;371        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;372    }
000008  4770              BX       lr
;;;373    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;165     */
;;;166    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168        uint32_t u32Divider = i2c->CLKDIV;
000002  6900              LDR      r0,[r0,#0x10]
;;;169    
;;;170        return (SystemCoreClock / ((u32Divider + 1) << 2));
000004  0081              LSLS     r1,r0,#2
000006  4803              LDR      r0,|L9.20|
000008  1d09              ADDS     r1,r1,#4
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f7fffffe          BL       __aeabi_uidivmod
;;;171    }
000010  bd10              POP      {r4,pc}
;;;172    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;229     */
;;;230    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;231    {
;;;232        return (i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;233    }
000004  4770              BX       lr
;;;234    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;201     */
;;;202    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;203    {
;;;204        return ((i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1 : 0);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;205    }
000006  4770              BX       lr
;;;206    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;215     */
;;;216    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;217    {
;;;218        return (i2c->STATUS);
;;;219    }
000002  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;36       */
;;;37     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;38     {
;;;39         uint32_t u32Div;
;;;40     
;;;41         u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000002  4d0c              LDR      r5,|L13.52|
000004  4604              MOV      r4,r0                 ;38
000006  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000008  220a              MOVS     r2,#0xa
00000a  0089              LSLS     r1,r1,#2
00000c  4350              MULS     r0,r2,r0
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  210a              MOVS     r1,#0xa
000014  1d40              ADDS     r0,r0,#5
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1e40              SUBS     r0,r0,#1
;;;42         i2c->CLKDIV = u32Div;
00001c  6120              STR      r0,[r4,#0x10]
;;;43     
;;;44         /* Enable I2C */
;;;45         i2c->CTL |= I2C_CTL_I2CEN_Msk;
00001e  6821              LDR      r1,[r4,#0]
000020  2240              MOVS     r2,#0x40
000022  4311              ORRS     r1,r1,r2
000024  6021              STR      r1,[r4,#0]
;;;46     
;;;47         return (SystemCoreClock / ((u32Div + 1) << 2));
000026  0081              LSLS     r1,r0,#2
000028  1d09              ADDS     r1,r1,#4
00002a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;48     }
000030  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;814      */
;;;815    uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;816    {
;;;817        uint8_t u8Xfering = 1, u8Err = 0, u8rData = 0, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  2300              MOVS     r3,#0
;;;818    
;;;819        I2C_START(i2c);                                                /* Send START */
000006  6802              LDR      r2,[r0,#0]
000008  461c              MOV      r4,r3                 ;817
00000a  2628              MOVS     r6,#0x28
00000c  4332              ORRS     r2,r2,r6
00000e  6002              STR      r2,[r0,#0]
;;;820    
;;;821        while (u8Xfering && (u8Err == 0))
;;;822        {
;;;823            I2C_WAIT_READY(i2c);
;;;824    
;;;825            switch (I2C_GET_STATUS(i2c))
;;;826            {
;;;827                case 0x08:
;;;828                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
;;;829                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;830                    break;
;;;831    
;;;832                case 0x40:                                             /* Slave Address ACK */
;;;833                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;834                    break;
;;;835    
;;;836                case 0x48:                                             /* Slave Address NACK */
;;;837                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;838                    u8Err = 1;
;;;839                    break;
;;;840    
;;;841                case 0x58:
;;;842                    u8rData = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
;;;843                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;844                    u8Xfering = 0;
;;;845                    break;
;;;846    
;;;847                case 0x38:                                             /* Arbitration Lost */
;;;848                default:                                               /* Unknow status */
;;;849                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L14.18|
000012  6802              LDR      r2,[r0,#0]            ;823
000014  0712              LSLS     r2,r2,#28             ;823
000016  d5fc              BPL      |L14.18|
000018  68c2              LDR      r2,[r0,#0xc]          ;825
00001a  2a08              CMP      r2,#8                 ;825
00001c  d00b              BEQ      |L14.54|
00001e  2a40              CMP      r2,#0x40              ;825
000020  d00c              BEQ      |L14.60|
000022  2a48              CMP      r2,#0x48              ;825
000024  d00c              BEQ      |L14.64|
000026  2a58              CMP      r2,#0x58              ;825
000028  d00d              BEQ      |L14.70|
00002a  6802              LDR      r2,[r0,#0]
00002c  43b2              BICS     r2,r2,r6
00002e  3218              ADDS     r2,r2,#0x18
000030  6002              STR      r2,[r0,#0]
;;;850                    u8Ctrl = I2C_CTL_SI;                         /* Clear SI and send STOP */
000032  2208              MOVS     r2,#8
;;;851                    u8Err = 1;
;;;852                    break;
000034  e005              B        |L14.66|
                  |L14.54|
000036  004a              LSLS     r2,r1,#1              ;828
000038  1c52              ADDS     r2,r2,#1              ;828
00003a  6082              STR      r2,[r0,#8]            ;828
                  |L14.60|
00003c  2208              MOVS     r2,#8                 ;833
00003e  e006              B        |L14.78|
                  |L14.64|
000040  2218              MOVS     r2,#0x18              ;837
                  |L14.66|
000042  2301              MOVS     r3,#1                 ;838
000044  e003              B        |L14.78|
                  |L14.70|
000046  6882              LDR      r2,[r0,#8]            ;842
000048  b2d4              UXTB     r4,r2                 ;842
00004a  2218              MOVS     r2,#0x18              ;843
00004c  2500              MOVS     r5,#0                 ;844
                  |L14.78|
;;;853            }
;;;854    
;;;855            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
00004e  6807              LDR      r7,[r0,#0]
000050  43b7              BICS     r7,r7,r6
000052  4317              ORRS     r7,r7,r2
000054  6007              STR      r7,[r0,#0]
000056  2d00              CMP      r5,#0                 ;821
000058  d002              BEQ      |L14.96|
00005a  2b00              CMP      r3,#0                 ;821
00005c  d0d9              BEQ      |L14.18|
00005e  e001              B        |L14.100|
                  |L14.96|
;;;856        }
;;;857    
;;;858        if (u8Err)
000060  2b00              CMP      r3,#0
000062  d000              BEQ      |L14.102|
                  |L14.100|
;;;859            u8rData = 0;                                                 /* If occurs error, return 0 */
000064  2400              MOVS     r4,#0
                  |L14.102|
;;;860    
;;;861        return u8rData;                                                  /* Return read data */
000066  4620              MOV      r0,r4
;;;862    }
000068  bdf0              POP      {r4-r7,pc}
;;;863    
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;953      */
;;;954    uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;955    {
;;;956        uint8_t u8Xfering = 1, u8Err = 0, u8rData = 0, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  2400              MOVS     r4,#0
;;;957    
;;;958        I2C_START(i2c);                                                /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  4625              MOV      r5,r4                 ;956
00000a  4622              MOV      r2,r4                 ;956
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;959    
;;;960        while (u8Xfering && (u8Err == 0))
;;;961        {
;;;962            I2C_WAIT_READY(i2c);
;;;963    
;;;964            switch (I2C_GET_STATUS(i2c))
;;;965            {
;;;966                case 0x08:
;;;967                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L15.20|
000014  6801              LDR      r1,[r0,#0]            ;962
000016  0709              LSLS     r1,r1,#28             ;962
000018  d5fc              BPL      |L15.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;964
00001c  074b              LSLS     r3,r1,#29             ;964
00001e  0f5b              LSRS     r3,r3,#29             ;964
000020  d126              BNE      |L15.112|
000022  10c9              ASRS     r1,r1,#3              ;964
000024  000b              MOVS     r3,r1                 ;964
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c23              DCB      0x0c,0x23
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c2313          DCB      0x0f,0x0c,0x23,0x13
000034  0c231523          DCB      0x0c,0x23,0x15,0x23
000038  6087              STR      r7,[r0,#8]
;;;968                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;969                    break;
00003a  e009              B        |L15.80|
;;;970    
;;;971                case 0x18:                                             /* Slave Address ACK */
;;;972                    I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;973                    break;
000040  e00c              B        |L15.92|
;;;974    
;;;975                case 0x20:                                             /* Slave Address NACK */
;;;976                case 0x30:                                             /* Master transmit data NACK */
;;;977                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L15.68|
;;;978                    u8Err = 1;
000044  2401              MOVS     r4,#1
000046  e009              B        |L15.92|
;;;979                    break;
;;;980    
;;;981                case 0x28:
;;;982                    u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;983                    break;
00004a  e007              B        |L15.92|
;;;984    
;;;985                case 0x10:
;;;986                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  6081              STR      r1,[r0,#8]
                  |L15.80|
000050  2208              MOVS     r2,#8                 ;968
000052  e003              B        |L15.92|
;;;987                    u8Ctrl = I2C_CTL_SI;                               /* Clear SI */
;;;988                    break;
;;;989    
;;;990                case 0x40:                                             /* Slave Address ACK */
;;;991                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;992                    break;
;;;993    
;;;994                case 0x48:                                             /* Slave Address NACK */
;;;995                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;996                    u8Err = 1;
;;;997                    break;
;;;998    
;;;999                case 0x58:
;;;1000                   u8rData = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
000054  6881              LDR      r1,[r0,#8]
;;;1001                   u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000056  2218              MOVS     r2,#0x18
000058  b2cd              UXTB     r5,r1                 ;1000
;;;1002                   u8Xfering = 0;
00005a  2600              MOVS     r6,#0
                  |L15.92|
;;;1003                   break;
;;;1004   
;;;1005               case 0x38:                                             /* Arbitration Lost */
;;;1006               default:                                               /* Unknow status */
;;;1007                   I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1008                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI and send STOP */
;;;1009                   u8Err = 1;
;;;1010                   break;
;;;1011           }
;;;1012   
;;;1013           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
00005c  6801              LDR      r1,[r0,#0]
00005e  233c              MOVS     r3,#0x3c
000060  4399              BICS     r1,r1,r3
000062  4311              ORRS     r1,r1,r2
000064  6001              STR      r1,[r0,#0]
000066  2e00              CMP      r6,#0                 ;960
000068  d009              BEQ      |L15.126|
00006a  2c00              CMP      r4,#0                 ;960
00006c  d0d2              BEQ      |L15.20|
00006e  e008              B        |L15.130|
                  |L15.112|
000070  6801              LDR      r1,[r0,#0]            ;1007
000072  223c              MOVS     r2,#0x3c              ;1007
000074  4391              BICS     r1,r1,r2              ;1007
000076  3118              ADDS     r1,r1,#0x18           ;1007
000078  6001              STR      r1,[r0,#0]            ;1007
00007a  2208              MOVS     r2,#8                 ;1008
00007c  e7e2              B        |L15.68|
                  |L15.126|
;;;1014       }
;;;1015   
;;;1016       if (u8Err)
00007e  2c00              CMP      r4,#0
000080  d000              BEQ      |L15.132|
                  |L15.130|
;;;1017           u8rData = 0;                                                 /* If occurs error, return 0 */
000082  2500              MOVS     r5,#0
                  |L15.132|
;;;1018   
;;;1019       return u8rData;                                                  /* Return read data */
000084  4628              MOV      r0,r5
;;;1020   }
000086  bdfe              POP      {r1-r7,pc}
;;;1021   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1125     */
;;;1126   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1127   {
;;;1128       uint8_t u8Xfering = 1, u8Err = 0, u8rData = 0, u8Addr = 1, u8Ctrl = 0;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1127
000006  2400              MOVS     r4,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1129   
;;;1130       I2C_START(i2c);                                                         /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  4625              MOV      r5,r4                 ;1128
000010  4622              MOV      r2,r4                 ;1128
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1131   
;;;1132       while (u8Xfering && (u8Err == 0))
;;;1133       {
;;;1134           I2C_WAIT_READY(i2c);
;;;1135   
;;;1136           switch (I2C_GET_STATUS(i2c))
;;;1137           {
;;;1138               case 0x08:
;;;1139                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L16.26|
00001a  6801              LDR      r1,[r0,#0]            ;1134
00001c  0709              LSLS     r1,r1,#28             ;1134
00001e  d5fc              BPL      |L16.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1136
000022  074b              LSLS     r3,r1,#29             ;1136
000024  0f5b              LSRS     r3,r3,#29             ;1136
000026  d130              BNE      |L16.138|
000028  10c9              ASRS     r1,r1,#3              ;1136
00002a  000b              MOVS     r3,r1                 ;1136
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c2d0719          DCB      0x0c,0x2d,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  2d1b0d2d          DCB      0x2d,0x1b,0x0d,0x2d
00003c  1d2d              DCB      0x1d,0x2d
00003e  6087              STR      r7,[r0,#8]
;;;1140                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1141                   break;
000040  e011              B        |L16.102|
;;;1142   
;;;1143               case 0x18:                                                      /* Slave Address ACK */
;;;1144                   I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1145                   break;
000048  e014              B        |L16.116|
;;;1146   
;;;1147               case 0x20:                                                      /* Slave Address NACK */
;;;1148               case 0x30:                                                      /* Master transmit data NACK */
;;;1149                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L16.76|
;;;1150                   u8Err = 1;
00004c  2401              MOVS     r4,#1
00004e  e011              B        |L16.116|
;;;1151                   break;
;;;1152   
;;;1153               case 0x28:
;;;1154                   if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L16.94|
;;;1155                   {
;;;1156                       I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1157                       u8Addr = 0;
00005a  2600              MOVS     r6,#0
00005c  e00a              B        |L16.116|
                  |L16.94|
;;;1158                   }
;;;1159                   else
;;;1160                       u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e008              B        |L16.116|
;;;1161   
;;;1162                   break;
;;;1163   
;;;1164               case 0x10:
;;;1165                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  6081              STR      r1,[r0,#8]
                  |L16.102|
000066  2208              MOVS     r2,#8                 ;1140
000068  e004              B        |L16.116|
;;;1166                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1167                   break;
;;;1168   
;;;1169               case 0x40:                                                      /* Slave Address ACK */
;;;1170                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1171                   break;
;;;1172   
;;;1173               case 0x48:                                                      /* Slave Address NACK */
;;;1174                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1175                   u8Err = 1;
;;;1176                   break;
;;;1177   
;;;1178               case 0x58:
;;;1179                   u8rData = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
;;;1180                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00006c  2218              MOVS     r2,#0x18
00006e  b2cd              UXTB     r5,r1                 ;1179
;;;1181                   u8Xfering = 0;
000070  2100              MOVS     r1,#0
000072  9100              STR      r1,[sp,#0]
                  |L16.116|
;;;1182                   break;
;;;1183   
;;;1184               case 0x38:                                                      /* Arbitration Lost */
;;;1185               default:                                                        /* Unknow status */
;;;1186                   I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1187                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
;;;1188                   u8Err = 1;
;;;1189                   break;
;;;1190           }
;;;1191   
;;;1192           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000074  6801              LDR      r1,[r0,#0]
000076  233c              MOVS     r3,#0x3c
000078  4399              BICS     r1,r1,r3
00007a  4311              ORRS     r1,r1,r2
00007c  6001              STR      r1,[r0,#0]
00007e  9900              LDR      r1,[sp,#0]            ;1132
000080  2900              CMP      r1,#0                 ;1132
000082  d009              BEQ      |L16.152|
000084  2c00              CMP      r4,#0                 ;1132
000086  d0c8              BEQ      |L16.26|
000088  e008              B        |L16.156|
                  |L16.138|
00008a  6801              LDR      r1,[r0,#0]            ;1186
00008c  223c              MOVS     r2,#0x3c              ;1186
00008e  4391              BICS     r1,r1,r2              ;1186
000090  3118              ADDS     r1,r1,#0x18           ;1186
000092  6001              STR      r1,[r0,#0]            ;1186
000094  2208              MOVS     r2,#8                 ;1187
000096  e7d9              B        |L16.76|
                  |L16.152|
;;;1193       }
;;;1194   
;;;1195       if (u8Err)
000098  2c00              CMP      r4,#0
00009a  d000              BEQ      |L16.158|
                  |L16.156|
;;;1196           u8rData = 0;                                                          /* If occurs error, return 0 */
00009c  2500              MOVS     r5,#0
                  |L16.158|
;;;1197   
;;;1198       return u8rData;                                                           /* Return read data */
00009e  4628              MOV      r0,r5
;;;1199   }
0000a0  b004              ADD      sp,sp,#0x10
0000a2  bdf0              POP      {r4-r7,pc}
;;;1200   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;878      */
;;;879    uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t *pu8rData, uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;880    {
000002  468c              MOV      r12,r1
;;;881        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  2600              MOVS     r6,#0
;;;882        uint32_t u32rxLen = 0;
;;;883    
;;;884        I2C_START(i2c);                                                /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;880
00000c  4634              MOV      r4,r6                 ;882
00000e  2528              MOVS     r5,#0x28
000010  4329              ORRS     r1,r1,r5
000012  6001              STR      r1,[r0,#0]
;;;885    
;;;886        while (u8Xfering && (u8Err == 0))
;;;887        {
;;;888            I2C_WAIT_READY(i2c);
;;;889    
;;;890            switch (I2C_GET_STATUS(i2c))
;;;891            {
;;;892                case 0x08:
;;;893                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
;;;894                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;895                    break;
;;;896    
;;;897                case 0x40:                                             /* Slave Address ACK */
;;;898                    u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;899                    break;
;;;900    
;;;901                case 0x48:                                             /* Slave Address NACK */
;;;902                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;903                    u8Err = 1;
;;;904                    break;
;;;905    
;;;906                case 0x50:
;;;907                    pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;908    
;;;909                    if (u32rxLen < (u32rLen - 1))
;;;910                    {
;;;911                        u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;912                    }
;;;913                    else
;;;914                    {
;;;915                        u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;916                    }
;;;917    
;;;918                    break;
;;;919    
;;;920                case 0x58:
;;;921                    pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;922                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;923                    u8Xfering = 0;
;;;924                    break;
;;;925    
;;;926                case 0x38:                                                    /* Arbitration Lost */
;;;927                default:                                                      /* Unknow status */
;;;928                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000014  213c              MOVS     r1,#0x3c
                  |L17.22|
000016  6805              LDR      r5,[r0,#0]            ;888
000018  072d              LSLS     r5,r5,#28             ;888
00001a  d5fc              BPL      |L17.22|
00001c  68c5              LDR      r5,[r0,#0xc]          ;890
00001e  2d48              CMP      r5,#0x48              ;890
000020  d014              BEQ      |L17.76|
000022  dc04              BGT      |L17.46|
000024  2d08              CMP      r5,#8                 ;890
000026  d00c              BEQ      |L17.66|
000028  2d40              CMP      r5,#0x40              ;890
00002a  d104              BNE      |L17.54|
00002c  e018              B        |L17.96|
                  |L17.46|
00002e  2d50              CMP      r5,#0x50              ;890
000030  d00f              BEQ      |L17.82|
000032  2d58              CMP      r5,#0x58              ;890
000034  d018              BEQ      |L17.104|
                  |L17.54|
000036  6805              LDR      r5,[r0,#0]
000038  438d              BICS     r5,r5,r1
00003a  3518              ADDS     r5,r5,#0x18
00003c  6005              STR      r5,[r0,#0]
;;;929                    u8Ctrl = I2C_CTL_SI;                                /* Clear SI and send STOP */
00003e  2508              MOVS     r5,#8
;;;930                    u8Err = 1;
;;;931                    break;
000040  e005              B        |L17.78|
                  |L17.66|
000042  4663              MOV      r3,r12                ;893
000044  005d              LSLS     r5,r3,#1              ;893
000046  1c6d              ADDS     r5,r5,#1              ;893
000048  6085              STR      r5,[r0,#8]            ;893
00004a  e00b              B        |L17.100|
                  |L17.76|
00004c  2518              MOVS     r5,#0x18              ;902
                  |L17.78|
00004e  2601              MOVS     r6,#1                 ;903
000050  e00f              B        |L17.114|
                  |L17.82|
000052  6885              LDR      r5,[r0,#8]            ;907
000054  5515              STRB     r5,[r2,r4]            ;907
000056  4673              MOV      r3,lr                 ;909
000058  1e5b              SUBS     r3,r3,#1              ;909
00005a  1c64              ADDS     r4,r4,#1              ;909
00005c  429c              CMP      r4,r3                 ;909
00005e  d201              BCS      |L17.100|
                  |L17.96|
000060  250c              MOVS     r5,#0xc               ;911
000062  e006              B        |L17.114|
                  |L17.100|
000064  2508              MOVS     r5,#8                 ;915
000066  e004              B        |L17.114|
                  |L17.104|
000068  6885              LDR      r5,[r0,#8]            ;921
00006a  5515              STRB     r5,[r2,r4]            ;921
00006c  2518              MOVS     r5,#0x18              ;922
00006e  2700              MOVS     r7,#0                 ;923
000070  1c64              ADDS     r4,r4,#1              ;923
                  |L17.114|
;;;932            }
;;;933    
;;;934            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
000072  6803              LDR      r3,[r0,#0]
000074  438b              BICS     r3,r3,r1
000076  431d              ORRS     r5,r5,r3
000078  6005              STR      r5,[r0,#0]
00007a  2f00              CMP      r7,#0                 ;886
00007c  d001              BEQ      |L17.130|
00007e  2e00              CMP      r6,#0                 ;886
000080  d0c9              BEQ      |L17.22|
                  |L17.130|
;;;935        }
;;;936    
;;;937        return u32rxLen;                                                      /* Return bytes length that have been received */
000082  4620              MOV      r0,r4
;;;938    }
000084  bdf0              POP      {r4-r7,pc}
;;;939    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1036     */
;;;1037   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *pu8rData, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1038   {
;;;1039       uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  2500              MOVS     r5,#0
;;;1040       uint32_t u32rxLen = 0;
;;;1041   
;;;1042       I2C_START(i2c);                                                /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  462a              MOV      r2,r5                 ;1039
00000a  462c              MOV      r4,r5                 ;1040
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1043   
;;;1044       while (u8Xfering && (u8Err == 0))
;;;1045       {
;;;1046           I2C_WAIT_READY(i2c);
;;;1047   
;;;1048           switch (I2C_GET_STATUS(i2c))
;;;1049           {
;;;1050               case 0x08:
;;;1051                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L18.20|
000014  6801              LDR      r1,[r0,#0]            ;1046
000016  0709              LSLS     r1,r1,#28             ;1046
000018  d5fc              BPL      |L18.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1048
00001c  074b              LSLS     r3,r1,#29             ;1048
00001e  0f5b              LSRS     r3,r3,#29             ;1048
000020  d135              BNE      |L18.142|
000022  10c9              ASRS     r1,r1,#3              ;1048
000024  000b              MOVS     r3,r1                 ;1048
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c32              DCB      0x0c,0x32
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c321c          DCB      0x0f,0x0c,0x32,0x1c
000034  0c142032          DCB      0x0c,0x14,0x20,0x32
000038  6087              STR      r7,[r0,#8]
;;;1052                   u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1053                   break;
00003a  e014              B        |L18.102|
;;;1054   
;;;1055               case 0x18:                                             /* Slave Address ACK */
;;;1056                   I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1057                   break;
000040  e019              B        |L18.118|
;;;1058   
;;;1059               case 0x20:                                             /* Slave Address NACK */
;;;1060               case 0x30:                                             /* Master transmit data NACK */
;;;1061                   u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L18.68|
;;;1062                   u8Err = 1;
000044  2501              MOVS     r5,#1
000046  e016              B        |L18.118|
;;;1063                   break;
;;;1064   
;;;1065               case 0x28:
;;;1066                   u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1067                   break;
00004a  e014              B        |L18.118|
;;;1068   
;;;1069               case 0x10:
;;;1070                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  6081              STR      r1,[r0,#8]
;;;1071                   u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1072                   break;
000050  e009              B        |L18.102|
;;;1073   
;;;1074               case 0x40:                                             /* Slave Address ACK */
;;;1075                   u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1076                   break;
;;;1077   
;;;1078               case 0x48:                                             /* Slave Address NACK */
;;;1079                   u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1080                   u8Err = 1;
;;;1081                   break;
;;;1082   
;;;1083               case 0x50:
;;;1084                   pu8rData[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000052  6881              LDR      r1,[r0,#8]
000054  9a03              LDR      r2,[sp,#0xc]
000056  5511              STRB     r1,[r2,r4]
;;;1085   
;;;1086                   if (u32rxLen < (u32rLen - 1))
000058  9909              LDR      r1,[sp,#0x24]
00005a  1c64              ADDS     r4,r4,#1
00005c  1e49              SUBS     r1,r1,#1
00005e  428c              CMP      r4,r1
000060  d201              BCS      |L18.102|
;;;1087                       u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000062  220c              MOVS     r2,#0xc
000064  e007              B        |L18.118|
                  |L18.102|
;;;1088                   else
;;;1089                       u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000066  2208              MOVS     r2,#8
000068  e005              B        |L18.118|
;;;1090   
;;;1091                   break;
;;;1092   
;;;1093               case 0x58:
;;;1094                   pu8rData[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
00006c  9a03              LDR      r2,[sp,#0xc]
;;;1095                   u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1096                   u8Xfering = 0;
00006e  2600              MOVS     r6,#0
000070  5511              STRB     r1,[r2,r4]            ;1094
000072  2218              MOVS     r2,#0x18              ;1095
000074  1c64              ADDS     r4,r4,#1
                  |L18.118|
;;;1097                   break;
;;;1098   
;;;1099               case 0x38:                                             /* Arbitration Lost */
;;;1100               default:                                               /* Unknow status */
;;;1101                   I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1102                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI and send STOP */
;;;1103                   u8Err = 1;
;;;1104                   break;
;;;1105           }
;;;1106   
;;;1107           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000076  6801              LDR      r1,[r0,#0]
000078  233c              MOVS     r3,#0x3c
00007a  4399              BICS     r1,r1,r3
00007c  4311              ORRS     r1,r1,r2
00007e  6001              STR      r1,[r0,#0]
000080  2e00              CMP      r6,#0                 ;1044
000082  d001              BEQ      |L18.136|
000084  2d00              CMP      r5,#0                 ;1044
000086  d0c5              BEQ      |L18.20|
                  |L18.136|
;;;1108       }
;;;1109   
;;;1110       return u32rxLen;                                               /* Return bytes length that have been received */
000088  4620              MOV      r0,r4
;;;1111   }
00008a  b004              ADD      sp,sp,#0x10
00008c  bdf0              POP      {r4-r7,pc}
                  |L18.142|
00008e  6801              LDR      r1,[r0,#0]            ;1101
000090  223c              MOVS     r2,#0x3c              ;1101
000092  4391              BICS     r1,r1,r2              ;1101
000094  3118              ADDS     r1,r1,#0x18           ;1101
000096  6001              STR      r1,[r0,#0]            ;1101
000098  2208              MOVS     r2,#8                 ;1102
00009a  e7d3              B        |L18.68|
;;;1112   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1215     */
;;;1216   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *pu8rData, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1217   {
;;;1218       uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1217
000006  2500              MOVS     r5,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1219       uint32_t u32rxLen = 0;
;;;1220   
;;;1221       I2C_START(i2c);                                                         /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  462a              MOV      r2,r5                 ;1218
000010  462c              MOV      r4,r5                 ;1219
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1222   
;;;1223       while (u8Xfering && (u8Err == 0))
;;;1224       {
;;;1225           I2C_WAIT_READY(i2c);
;;;1226   
;;;1227           switch (I2C_GET_STATUS(i2c))
;;;1228           {
;;;1229               case 0x08:
;;;1230                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L19.26|
00001a  6801              LDR      r1,[r0,#0]            ;1225
00001c  0709              LSLS     r1,r1,#28             ;1225
00001e  d5fc              BPL      |L19.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1227
000022  074b              LSLS     r3,r1,#29             ;1227
000024  0f5b              LSRS     r3,r3,#29             ;1227
000026  d13f              BNE      |L19.168|
000028  10c9              ASRS     r1,r1,#3              ;1227
00002a  000b              MOVS     r3,r1                 ;1227
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c3c0719          DCB      0x0c,0x3c,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  3c240d1c          DCB      0x3c,0x24,0x0d,0x1c
00003c  283c              DCB      0x28,0x3c
00003e  6087              STR      r7,[r0,#8]
;;;1231                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1232                   break;
000040  e01c              B        |L19.124|
;;;1233   
;;;1234               case 0x18:                                                      /* Slave Address ACK */
;;;1235                   I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1236                   break;
000048  e021              B        |L19.142|
;;;1237   
;;;1238               case 0x20:                                                      /* Slave Address NACK */
;;;1239               case 0x30:                                                      /* Master transmit data NACK */
;;;1240                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L19.76|
;;;1241                   u8Err = 1;
00004c  2501              MOVS     r5,#1
00004e  e01e              B        |L19.142|
;;;1242                   break;
;;;1243   
;;;1244               case 0x28:
;;;1245                   if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L19.94|
;;;1246                   {
;;;1247                       I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1248                       u8Addr = 0;
00005a  2600              MOVS     r6,#0
00005c  e017              B        |L19.142|
                  |L19.94|
;;;1249                   }
;;;1250                   else
;;;1251                       u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e015              B        |L19.142|
;;;1252   
;;;1253                   break;
;;;1254   
;;;1255               case 0x10:
;;;1256                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  6081              STR      r1,[r0,#8]
;;;1257                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1258                   break;
000066  e009              B        |L19.124|
;;;1259   
;;;1260               case 0x40:                                                      /* Slave Address ACK */
;;;1261                   u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1262                   break;
;;;1263   
;;;1264               case 0x48:                                                      /* Slave Address NACK */
;;;1265                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1266                   u8Err = 1;
;;;1267                   break;
;;;1268   
;;;1269               case 0x50:
;;;1270                   pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000068  6881              LDR      r1,[r0,#8]
00006a  9a04              LDR      r2,[sp,#0x10]
00006c  5511              STRB     r1,[r2,r4]
;;;1271   
;;;1272                   if (u32rxLen < (u32rLen - 1))
00006e  990a              LDR      r1,[sp,#0x28]
000070  1c64              ADDS     r4,r4,#1
000072  1e49              SUBS     r1,r1,#1
000074  428c              CMP      r4,r1
000076  d201              BCS      |L19.124|
;;;1273                       u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
000078  220c              MOVS     r2,#0xc
00007a  e008              B        |L19.142|
                  |L19.124|
;;;1274                   else
;;;1275                       u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
00007c  2208              MOVS     r2,#8
00007e  e006              B        |L19.142|
;;;1276   
;;;1277                   break;
;;;1278   
;;;1279               case 0x58:
;;;1280                   pu8rData[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000080  6881              LDR      r1,[r0,#8]
000082  9a04              LDR      r2,[sp,#0x10]
000084  5511              STRB     r1,[r2,r4]
;;;1281                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1282                   u8Xfering = 0;
000086  2100              MOVS     r1,#0
000088  2218              MOVS     r2,#0x18              ;1281
00008a  1c64              ADDS     r4,r4,#1
00008c  9100              STR      r1,[sp,#0]
                  |L19.142|
;;;1283                   break;
;;;1284   
;;;1285               case 0x38:                                                      /* Arbitration Lost */
;;;1286               default:                                                        /* Unknow status */
;;;1287                   I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
;;;1288                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
;;;1289                   u8Err = 1;
;;;1290                   break;
;;;1291           }
;;;1292   
;;;1293           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00008e  6801              LDR      r1,[r0,#0]
000090  233c              MOVS     r3,#0x3c
000092  4399              BICS     r1,r1,r3
000094  4311              ORRS     r1,r1,r2
000096  6001              STR      r1,[r0,#0]
000098  9900              LDR      r1,[sp,#0]            ;1223
00009a  2900              CMP      r1,#0                 ;1223
00009c  d001              BEQ      |L19.162|
00009e  2d00              CMP      r5,#0                 ;1223
0000a0  d0bb              BEQ      |L19.26|
                  |L19.162|
;;;1294       }
;;;1295   
;;;1296       return u32rxLen;                                                        /* Return bytes length that have been received */
0000a2  4620              MOV      r0,r4
;;;1297   }
0000a4  b005              ADD      sp,sp,#0x14
0000a6  bdf0              POP      {r4-r7,pc}
                  |L19.168|
0000a8  6801              LDR      r1,[r0,#0]            ;1287
0000aa  223c              MOVS     r2,#0x3c              ;1287
0000ac  4391              BICS     r1,r1,r2              ;1287
0000ae  3118              ADDS     r1,r1,#0x18           ;1287
0000b0  6001              STR      r1,[r0,#0]            ;1287
0000b2  2208              MOVS     r2,#8                 ;1288
0000b4  e7ca              B        |L19.76|
;;;1298   
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;182     */
;;;183    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185        uint32_t u32Div;
;;;186    
;;;187        u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000004  4809              LDR      r0,|L20.44|
000006  220a              MOVS     r2,#0xa
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  0089              LSLS     r1,r1,#2
00000c  4605              MOV      r5,r0
00000e  4350              MULS     r0,r2,r0
000010  f7fffffe          BL       __aeabi_uidivmod
000014  210a              MOVS     r1,#0xa
000016  1d40              ADDS     r0,r0,#5
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  1e40              SUBS     r0,r0,#1
;;;188        i2c->CLKDIV = u32Div;
00001e  6120              STR      r0,[r4,#0x10]
;;;189    
;;;190        return (SystemCoreClock / ((u32Div + 1) << 2));
000020  0081              LSLS     r1,r0,#2
000022  4628              MOV      r0,r5
000024  1d09              ADDS     r1,r1,#4
000026  f7fffffe          BL       __aeabi_uidivmod
;;;191    }
00002a  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

                  |L20.44|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;244     */
;;;245    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;246    {
;;;247        i2c->DAT = u8Data;
;;;248    }
000002  4770              BX       lr
;;;249    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;263     */
;;;264    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;265    {
;;;266        switch (u8SlaveNo)
;;;267        {
;;;268            case 1:
;;;269                i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
000002  431a              ORRS     r2,r2,r3
000004  2901              CMP      r1,#1                 ;266
000006  d005              BEQ      |L22.20|
000008  2902              CMP      r1,#2                 ;266
00000a  d005              BEQ      |L22.24|
00000c  2903              CMP      r1,#3                 ;266
00000e  d005              BEQ      |L22.28|
;;;270                break;
;;;271    
;;;272            case 2:
;;;273                i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
;;;274                break;
;;;275    
;;;276            case 3:
;;;277                i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
;;;278                break;
;;;279    
;;;280            case 0:
;;;281            default:
;;;282                i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;283                break;
;;;284        }
;;;285    }
000012  4770              BX       lr
                  |L22.20|
000014  6182              STR      r2,[r0,#0x18]         ;269
000016  4770              BX       lr
                  |L22.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;273
00001a  4770              BX       lr
                  |L22.28|
00001c  6202              STR      r2,[r0,#0x20]         ;277
00001e  4770              BX       lr
;;;286    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;298     */
;;;299    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;300    {
;;;301        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L23.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L23.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L23.26|
;;;302        {
;;;303            case 1:
;;;304                i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
;;;305                break;
;;;306    
;;;307            case 2:
;;;308                i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
;;;309                break;
;;;310    
;;;311            case 3:
;;;312                i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
;;;313                break;
;;;314    
;;;315            case 0:
;;;316            default:
;;;317                i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
00000e  6242              STR      r2,[r0,#0x24]
;;;318                break;
;;;319        }
;;;320    }
000010  4770              BX       lr
                  |L23.18|
000012  6282              STR      r2,[r0,#0x28]         ;304
000014  4770              BX       lr
                  |L23.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;308
000018  4770              BX       lr
                  |L23.26|
00001a  6302              STR      r2,[r0,#0x30]         ;312
00001c  4770              BX       lr
;;;321    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;107      */
;;;108    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;109    {
;;;110        uint32_t u32Reg = 0;
000002  2400              MOVS     r4,#0
;;;111    
;;;112        if (u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L24.12|
;;;113            u32Reg |= I2C_CTL_STA;
00000a  2420              MOVS     r4,#0x20
                  |L24.12|
;;;114    
;;;115        if (u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L24.20|
;;;116            u32Reg |= I2C_CTL_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L24.20|
;;;117    
;;;118        if (u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L24.28|
;;;119            u32Reg |= I2C_CTL_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L24.28|
;;;120    
;;;121        if (u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L24.36|
;;;122            u32Reg |= I2C_CTL_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L24.36|
;;;123    
;;;124        i2c->CTL = (i2c->CTL & ~0x3C) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;125    }
00002e  bd30              POP      {r4,r5,pc}
;;;126    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;403    
;;;404    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t u8Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;405    {
;;;406        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;407    
;;;408        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;406
00000a  2728              MOVS     r7,#0x28
00000c  433e              ORRS     r6,r6,r7
00000e  6006              STR      r6,[r0,#0]
;;;409    
;;;410        while (u8Xfering && (u8Err == 0))
;;;411        {
;;;412            I2C_WAIT_READY(i2c);
;;;413    
;;;414            switch (I2C_GET_STATUS(i2c))
;;;415            {
;;;416                case 0x08:
;;;417                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;418                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;419                    break;
;;;420    
;;;421                case 0x18:                                           /* Slave Address ACK */
;;;422                    I2C_SET_DATA(i2c, u8Data);                         /* Write data to I2CDAT */
;;;423                    break;
;;;424    
;;;425                case 0x20:                                           /* Slave Address NACK */
;;;426                case 0x30:                                           /* Master transmit data NACK */
;;;427                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;428                    u8Err = 1;
;;;429                    break;
;;;430    
;;;431                case 0x28:
;;;432                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;433                    u8Xfering = 0;
;;;434                    break;
;;;435    
;;;436                case 0x38:                                           /* Arbitration Lost */
;;;437                default:                                             /* Unknow status */
;;;438                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L25.18|
000012  6807              LDR      r7,[r0,#0]            ;412
000014  073f              LSLS     r7,r7,#28             ;412
000016  d5fc              BPL      |L25.18|
000018  68c7              LDR      r7,[r0,#0xc]          ;414
00001a  2f20              CMP      r7,#0x20              ;414
00001c  d015              BEQ      |L25.74|
00001e  dc04              BGT      |L25.42|
000020  2f08              CMP      r7,#8                 ;414
000022  d00c              BEQ      |L25.62|
000024  2f18              CMP      r7,#0x18              ;414
000026  d104              BNE      |L25.50|
000028  e00d              B        |L25.70|
                  |L25.42|
00002a  2f28              CMP      r7,#0x28              ;414
00002c  d010              BEQ      |L25.80|
00002e  2f30              CMP      r7,#0x30              ;414
000030  d00b              BEQ      |L25.74|
                  |L25.50|
000032  6803              LDR      r3,[r0,#0]
000034  43b3              BICS     r3,r3,r6
000036  3318              ADDS     r3,r3,#0x18
000038  6003              STR      r3,[r0,#0]
;;;439                    u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
00003a  2308              MOVS     r3,#8
;;;440                    u8Err = 1;
;;;441                    break;
00003c  e006              B        |L25.76|
                  |L25.62|
00003e  004b              LSLS     r3,r1,#1              ;417
000040  6083              STR      r3,[r0,#8]            ;417
000042  2308              MOVS     r3,#8                 ;418
000044  e006              B        |L25.84|
                  |L25.70|
000046  6082              STR      r2,[r0,#8]            ;422
000048  e004              B        |L25.84|
                  |L25.74|
00004a  2318              MOVS     r3,#0x18              ;427
                  |L25.76|
00004c  2401              MOVS     r4,#1                 ;428
00004e  e001              B        |L25.84|
                  |L25.80|
000050  2318              MOVS     r3,#0x18              ;432
000052  2500              MOVS     r5,#0                 ;433
                  |L25.84|
;;;442            }
;;;443    
;;;444            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000054  6807              LDR      r7,[r0,#0]
000056  43b7              BICS     r7,r7,r6
000058  431f              ORRS     r7,r7,r3
00005a  6007              STR      r7,[r0,#0]
00005c  2d00              CMP      r5,#0                 ;410
00005e  d001              BEQ      |L25.100|
000060  2c00              CMP      r4,#0                 ;410
000062  d0d6              BEQ      |L25.18|
                  |L25.100|
000064  4620              MOV      r0,r4                 ;410
;;;445        }
;;;446    
;;;447        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000066  4328              ORRS     r0,r0,r5
;;;448    }
000068  bdf0              POP      {r4-r7,pc}
;;;449    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;528    
;;;529    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t u8Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;530    {
000002  469e              MOV      lr,r3
;;;531        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2601              MOVS     r6,#1
000006  4613              MOV      r3,r2                 ;530
000008  2500              MOVS     r5,#0
;;;532        uint32_t u32txLen = 0;
;;;533    
;;;534        I2C_START(i2c);                                              /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;530
00000e  462c              MOV      r4,r5                 ;531
000010  462f              MOV      r7,r5                 ;532
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;535    
;;;536        while (u8Xfering && (u8Err == 0))
;;;537        {
;;;538            I2C_WAIT_READY(i2c);
;;;539    
;;;540            switch (I2C_GET_STATUS(i2c))
;;;541            {
;;;542                case 0x08:
;;;543                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Send Slave address with write bit */
;;;544                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;545                    break;
;;;546    
;;;547                case 0x18:                                           /* Slave Address ACK */
;;;548                    I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;549                    break;
;;;550    
;;;551                case 0x20:                                           /* Slave Address NACK */
;;;552                case 0x30:                                           /* Master transmit data NACK */
;;;553                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;554                    u8Err = 1;
;;;555                    break;
;;;556    
;;;557                case 0x28:
;;;558                    if (u32txLen < 1)
;;;559                    {
;;;560                        I2C_SET_DATA(i2c, u8Data);
;;;561                        u32txLen++;
;;;562                    }
;;;563                    else
;;;564                    {
;;;565                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;566                        u8Xfering = 0;
;;;567                    }
;;;568    
;;;569                    break;
;;;570    
;;;571                case 0x38:                                           /* Arbitration Lost */
;;;572                default:                                             /* Unknow status */
;;;573                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L26.26|
00001a  6801              LDR      r1,[r0,#0]            ;538
00001c  0709              LSLS     r1,r1,#28             ;538
00001e  d5fc              BPL      |L26.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;540
000022  2920              CMP      r1,#0x20              ;540
000024  d016              BEQ      |L26.84|
000026  dc04              BGT      |L26.50|
000028  2908              CMP      r1,#8                 ;540
00002a  d00c              BEQ      |L26.70|
00002c  2918              CMP      r1,#0x18              ;540
00002e  d104              BNE      |L26.58|
000030  e00e              B        |L26.80|
                  |L26.50|
000032  2928              CMP      r1,#0x28              ;540
000034  d011              BEQ      |L26.90|
000036  2930              CMP      r1,#0x30              ;540
000038  d00c              BEQ      |L26.84|
                  |L26.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;574                    u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
000042  2408              MOVS     r4,#8
;;;575                    u8Err = 1;
;;;576                    break;
000044  e007              B        |L26.86|
                  |L26.70|
000046  4661              MOV      r1,r12                ;543
000048  004c              LSLS     r4,r1,#1              ;543
00004a  6084              STR      r4,[r0,#8]            ;543
00004c  2408              MOVS     r4,#8                 ;544
00004e  e00c              B        |L26.106|
                  |L26.80|
000050  6083              STR      r3,[r0,#8]            ;548
000052  e00a              B        |L26.106|
                  |L26.84|
000054  2418              MOVS     r4,#0x18              ;553
                  |L26.86|
000056  2501              MOVS     r5,#1                 ;554
000058  e007              B        |L26.106|
                  |L26.90|
00005a  2f00              CMP      r7,#0                 ;558
00005c  d002              BEQ      |L26.100|
00005e  2418              MOVS     r4,#0x18              ;565
000060  2600              MOVS     r6,#0                 ;566
000062  e002              B        |L26.106|
                  |L26.100|
000064  4671              MOV      r1,lr                 ;560
000066  6081              STR      r1,[r0,#8]            ;560
000068  2701              MOVS     r7,#1                 ;561
                  |L26.106|
;;;577            }
;;;578    
;;;579            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00006a  6801              LDR      r1,[r0,#0]
00006c  4391              BICS     r1,r1,r2
00006e  4321              ORRS     r1,r1,r4
000070  6001              STR      r1,[r0,#0]
000072  2e00              CMP      r6,#0                 ;536
000074  d001              BEQ      |L26.122|
000076  2d00              CMP      r5,#0                 ;536
000078  d0cf              BEQ      |L26.26|
                  |L26.122|
00007a  4628              MOV      r0,r5                 ;536
;;;580        }
;;;581    
;;;582        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
00007c  4330              ORRS     r0,r0,r6
;;;583    }
00007e  bdf0              POP      {r4-r7,pc}
;;;584    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;668    
;;;669    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t u8Data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;670    {
;;;671        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  468e              MOV      lr,r1                 ;670
000006  2400              MOVS     r4,#0
;;;672        uint32_t u32txLen = 0;
;;;673    
;;;674        I2C_START(i2c);                                                         /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;670
00000c  462f              MOV      r7,r5                 ;671
00000e  4623              MOV      r3,r4                 ;671
000010  4626              MOV      r6,r4                 ;672
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L27.24|
;;;675    
;;;676        while (u8Xfering && (u8Err == 0))
;;;677        {
;;;678            I2C_WAIT_READY(i2c);
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L27.24|
;;;679    
;;;680            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d019              BEQ      |L27.88|
000024  dc04              BGT      |L27.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L27.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L27.56|
00002e  e00f              B        |L27.80|
                  |L27.48|
000030  2a28              CMP      r2,#0x28
000032  d014              BEQ      |L27.94|
000034  2a30              CMP      r2,#0x30
000036  d00f              BEQ      |L27.88|
                  |L27.56|
;;;681            {
;;;682                case 0x08:
;;;683                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
;;;684                    u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;685                    break;
;;;686    
;;;687                case 0x18:                                                      /* Slave Address ACK */
;;;688                    I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
;;;689                    break;
;;;690    
;;;691                case 0x20:                                                      /* Slave Address NACK */
;;;692                case 0x30:                                                      /* Master transmit data NACK */
;;;693                    u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;694                    u8Err = 1;
;;;695                    break;
;;;696    
;;;697                case 0x28:
;;;698                    if (u8Addr)
;;;699                    {
;;;700                        I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
;;;701                        u8Addr = 0;
;;;702                    }
;;;703                    else if ((u32txLen < 1) && (u8Addr == 0))
;;;704                    {
;;;705                        I2C_SET_DATA(i2c, u8Data);
;;;706                        u32txLen++;
;;;707                    }
;;;708                    else
;;;709                    {
;;;710                        u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;711                        u8Xfering = 0;
;;;712                    }
;;;713    
;;;714                    break;
;;;715    
;;;716                case 0x38:                                                      /* Arbitration Lost */
;;;717                default:                                                        /* Unknow status */
;;;718                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;719                    u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
000042  2308              MOVS     r3,#8
;;;720                    u8Err = 1;
;;;721                    break;
000044  e009              B        |L27.90|
                  |L27.70|
000046  4671              MOV      r1,lr                 ;683
000048  0049              LSLS     r1,r1,#1              ;683
00004a  6081              STR      r1,[r0,#8]            ;683
00004c  2308              MOVS     r3,#8                 ;684
00004e  e015              B        |L27.124|
                  |L27.80|
000050  4661              MOV      r1,r12                ;688
000052  0a0a              LSRS     r2,r1,#8              ;688
000054  6082              STR      r2,[r0,#8]            ;688
000056  e011              B        |L27.124|
                  |L27.88|
000058  2318              MOVS     r3,#0x18              ;693
                  |L27.90|
00005a  2401              MOVS     r4,#1                 ;694
00005c  e00e              B        |L27.124|
                  |L27.94|
00005e  2f00              CMP      r7,#0                 ;698
000060  d004              BEQ      |L27.108|
000062  4661              MOV      r1,r12                ;700
000064  b2c9              UXTB     r1,r1                 ;700
000066  6081              STR      r1,[r0,#8]            ;700
000068  2700              MOVS     r7,#0                 ;701
00006a  e007              B        |L27.124|
                  |L27.108|
00006c  2e00              CMP      r6,#0                 ;703
00006e  d002              BEQ      |L27.118|
000070  2318              MOVS     r3,#0x18              ;710
000072  2500              MOVS     r5,#0                 ;711
000074  e002              B        |L27.124|
                  |L27.118|
000076  9903              LDR      r1,[sp,#0xc]          ;705
000078  6081              STR      r1,[r0,#8]            ;705
00007a  2601              MOVS     r6,#1                 ;706
                  |L27.124|
;;;722            }
;;;723    
;;;724            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00007c  6801              LDR      r1,[r0,#0]
00007e  223c              MOVS     r2,#0x3c
000080  4391              BICS     r1,r1,r2
000082  460a              MOV      r2,r1
000084  431a              ORRS     r2,r2,r3
000086  6002              STR      r2,[r0,#0]
000088  2d00              CMP      r5,#0                 ;676
00008a  d001              BEQ      |L27.144|
00008c  2c00              CMP      r4,#0                 ;676
00008e  d0c3              BEQ      |L27.24|
                  |L27.144|
000090  4620              MOV      r0,r4                 ;676
;;;725        }
;;;726    
;;;727        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
000092  4328              ORRS     r0,r0,r5
;;;728    }
000094  b004              ADD      sp,sp,#0x10
000096  bdf0              POP      {r4-r7,pc}
;;;729    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;463    
;;;464    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t *pu8Data, uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;465    {
000002  469e              MOV      lr,r3
;;;466        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  4613              MOV      r3,r2                 ;465
000008  2600              MOVS     r6,#0
;;;467        uint32_t u32txLen = 0;
;;;468    
;;;469        I2C_START(i2c);                                              /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;465
00000e  4634              MOV      r4,r6                 ;466
000010  4635              MOV      r5,r6                 ;467
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;470    
;;;471        while (u8Xfering && (u8Err == 0))
;;;472        {
;;;473            I2C_WAIT_READY(i2c);
;;;474    
;;;475            switch (I2C_GET_STATUS(i2c))
;;;476            {
;;;477                case 0x08:
;;;478                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;479                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;480                    break;
;;;481    
;;;482                case 0x18:                                           /* Slave Address ACK */
;;;483                case 0x28:
;;;484                    if (u32txLen < u32wLen)
;;;485                        I2C_SET_DATA(i2c, pu8Data[u32txLen++]);                /* Write Data to I2CDAT */
;;;486                    else
;;;487                    {
;;;488                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;489                        u8Xfering = 0;
;;;490                    }
;;;491    
;;;492                    break;
;;;493    
;;;494                case 0x20:                                           /* Slave Address NACK */
;;;495                case 0x30:                                           /* Master transmit data NACK */
;;;496                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;497                    u8Err = 1;
;;;498                    break;
;;;499    
;;;500                case 0x38:                                           /* Arbitration Lost */
;;;501                default:                                             /* Unknow status */
;;;502                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L28.26|
00001a  6801              LDR      r1,[r0,#0]            ;473
00001c  0709              LSLS     r1,r1,#28             ;473
00001e  d5fc              BPL      |L28.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;475
000022  2920              CMP      r1,#0x20              ;475
000024  d01d              BEQ      |L28.98|
000026  dc04              BGT      |L28.50|
000028  2908              CMP      r1,#8                 ;475
00002a  d00c              BEQ      |L28.70|
00002c  2918              CMP      r1,#0x18              ;475
00002e  d104              BNE      |L28.58|
000030  e00e              B        |L28.80|
                  |L28.50|
000032  2928              CMP      r1,#0x28              ;475
000034  d00c              BEQ      |L28.80|
000036  2930              CMP      r1,#0x30              ;475
000038  d013              BEQ      |L28.98|
                  |L28.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;503                    u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
000042  2408              MOVS     r4,#8
;;;504                    u8Err = 1;
;;;505                    break;
000044  e00e              B        |L28.100|
                  |L28.70|
000046  4661              MOV      r1,r12                ;478
000048  004c              LSLS     r4,r1,#1              ;478
00004a  6084              STR      r4,[r0,#8]            ;478
00004c  2408              MOVS     r4,#8                 ;479
00004e  e00a              B        |L28.102|
                  |L28.80|
000050  4575              CMP      r5,lr                 ;484
000052  d203              BCS      |L28.92|
000054  5d59              LDRB     r1,[r3,r5]            ;485
000056  6081              STR      r1,[r0,#8]            ;485
000058  1c6d              ADDS     r5,r5,#1              ;485
00005a  e004              B        |L28.102|
                  |L28.92|
00005c  2418              MOVS     r4,#0x18              ;488
00005e  2700              MOVS     r7,#0                 ;489
000060  e001              B        |L28.102|
                  |L28.98|
000062  2418              MOVS     r4,#0x18              ;496
                  |L28.100|
000064  2601              MOVS     r6,#1                 ;497
                  |L28.102|
;;;506            }
;;;507    
;;;508            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000066  6801              LDR      r1,[r0,#0]
000068  4391              BICS     r1,r1,r2
00006a  4321              ORRS     r1,r1,r4
00006c  6001              STR      r1,[r0,#0]
00006e  2f00              CMP      r7,#0                 ;471
000070  d001              BEQ      |L28.118|
000072  2e00              CMP      r6,#0                 ;471
000074  d0d1              BEQ      |L28.26|
                  |L28.118|
;;;509        }
;;;510    
;;;511        return u32txLen;                                             /* Return bytes length that have been transmitted */
000076  4628              MOV      r0,r5
;;;512    }
000078  bdf0              POP      {r4-r7,pc}
;;;513    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;600    
;;;601    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t *pu8Data, uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;602    {
000002  469e              MOV      lr,r3
;;;603        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  460b              MOV      r3,r1                 ;602
000008  2600              MOVS     r6,#0
;;;604        uint32_t u32txLen = 0;
;;;605    
;;;606        I2C_START(i2c);                                              /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  4694              MOV      r12,r2                ;602
00000e  4634              MOV      r4,r6                 ;603
000010  4635              MOV      r5,r6                 ;604
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;607    
;;;608        while (u8Xfering && (u8Err == 0))
;;;609        {
;;;610            I2C_WAIT_READY(i2c);
;;;611    
;;;612            switch (I2C_GET_STATUS(i2c))
;;;613            {
;;;614                case 0x08:
;;;615                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;616                    u8Ctrl = I2C_CTL_SI;
;;;617                    break;
;;;618    
;;;619                case 0x18:                                           /* Slave Address ACK */
;;;620                    I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;621                    break;
;;;622    
;;;623                case 0x20:                                           /* Slave Address NACK */
;;;624                case 0x30:                                           /* Master transmit data NACK */
;;;625                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;626                    u8Err = 1;
;;;627                    break;
;;;628    
;;;629                case 0x28:
;;;630                    if (u32txLen < u32wLen)
;;;631                        I2C_SET_DATA(i2c, pu8Data[u32txLen++]);
;;;632                    else
;;;633                    {
;;;634                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;635                        u8Xfering = 0;
;;;636                    }
;;;637    
;;;638                    break;
;;;639    
;;;640                case 0x38:                                           /* Arbitration Lost */
;;;641                default:                                             /* Unknow status */
;;;642                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L29.26|
00001a  6801              LDR      r1,[r0,#0]            ;610
00001c  0709              LSLS     r1,r1,#28             ;610
00001e  d5fc              BPL      |L29.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;612
000022  2920              CMP      r1,#0x20              ;612
000024  d016              BEQ      |L29.84|
000026  dc04              BGT      |L29.50|
000028  2908              CMP      r1,#8                 ;612
00002a  d00c              BEQ      |L29.70|
00002c  2918              CMP      r1,#0x18              ;612
00002e  d104              BNE      |L29.58|
000030  e00d              B        |L29.78|
                  |L29.50|
000032  2928              CMP      r1,#0x28              ;612
000034  d011              BEQ      |L29.90|
000036  2930              CMP      r1,#0x30              ;612
000038  d00c              BEQ      |L29.84|
                  |L29.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;643                    u8Ctrl = I2C_CTL_SI;                       /* Clear SI and send STOP */
000042  2408              MOVS     r4,#8
;;;644                    u8Err = 1;
;;;645                    break;
000044  e007              B        |L29.86|
                  |L29.70|
000046  005c              LSLS     r4,r3,#1              ;615
000048  6084              STR      r4,[r0,#8]            ;615
00004a  2408              MOVS     r4,#8                 ;616
00004c  e00f              B        |L29.110|
                  |L29.78|
00004e  4661              MOV      r1,r12                ;620
000050  6081              STR      r1,[r0,#8]            ;620
000052  e00c              B        |L29.110|
                  |L29.84|
000054  2418              MOVS     r4,#0x18              ;625
                  |L29.86|
000056  2601              MOVS     r6,#1                 ;626
000058  e009              B        |L29.110|
                  |L29.90|
00005a  9905              LDR      r1,[sp,#0x14]         ;630
00005c  428d              CMP      r5,r1                 ;630
00005e  d204              BCS      |L29.106|
000060  4671              MOV      r1,lr                 ;631
000062  5d49              LDRB     r1,[r1,r5]            ;631
000064  6081              STR      r1,[r0,#8]            ;631
000066  1c6d              ADDS     r5,r5,#1              ;631
000068  e001              B        |L29.110|
                  |L29.106|
00006a  2418              MOVS     r4,#0x18              ;634
00006c  2700              MOVS     r7,#0                 ;635
                  |L29.110|
;;;646            }
;;;647    
;;;648            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00006e  6801              LDR      r1,[r0,#0]
000070  4391              BICS     r1,r1,r2
000072  4321              ORRS     r1,r1,r4
000074  6001              STR      r1,[r0,#0]
000076  2f00              CMP      r7,#0                 ;608
000078  d001              BEQ      |L29.126|
00007a  2e00              CMP      r6,#0                 ;608
00007c  d0cd              BEQ      |L29.26|
                  |L29.126|
;;;649        }
;;;650    
;;;651        return u32txLen;                                             /* Return bytes length that have been transmitted */
00007e  4628              MOV      r0,r5
;;;652    }
000080  bdf0              POP      {r4-r7,pc}
;;;653    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;745    
;;;746    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t *pu8Data, uint32_t u32wLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;747    {
;;;748        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2701              MOVS     r7,#1
000004  468e              MOV      lr,r1                 ;747
000006  2500              MOVS     r5,#0
;;;749        uint32_t u32txLen = 0;
;;;750    
;;;751        I2C_START(i2c);                                                         /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;747
00000c  463e              MOV      r6,r7                 ;748
00000e  462b              MOV      r3,r5                 ;748
000010  462c              MOV      r4,r5                 ;749
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L30.24|
;;;752    
;;;753        while (u8Xfering && (u8Err == 0))
;;;754        {
;;;755            I2C_WAIT_READY(i2c);
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L30.24|
;;;756    
;;;757            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d019              BEQ      |L30.88|
000024  dc04              BGT      |L30.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L30.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L30.56|
00002e  e00f              B        |L30.80|
                  |L30.48|
000030  2a28              CMP      r2,#0x28
000032  d014              BEQ      |L30.94|
000034  2a30              CMP      r2,#0x30
000036  d00f              BEQ      |L30.88|
                  |L30.56|
;;;758            {
;;;759                case 0x08:
;;;760                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
;;;761                    u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;762                    break;
;;;763    
;;;764                case 0x18:                                                      /* Slave Address ACK */
;;;765                    I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
;;;766                    break;
;;;767    
;;;768                case 0x20:                                                      /* Slave Address NACK */
;;;769                case 0x30:                                                      /* Master transmit data NACK */
;;;770                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;771                    u8Err = 1;
;;;772                    break;
;;;773    
;;;774                case 0x28:
;;;775                    if (u8Addr)
;;;776                    {
;;;777                        I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
;;;778                        u8Addr = 0;
;;;779                    }
;;;780                    else if ((u32txLen < u32wLen) && (u8Addr == 0))
;;;781                        I2C_SET_DATA(i2c, pu8Data[u32txLen++]);                           /* Write data to Register I2CDAT*/
;;;782                    else
;;;783                    {
;;;784                        u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;785                        u8Xfering = 0;
;;;786                    }
;;;787    
;;;788                    break;
;;;789    
;;;790                case 0x38:                                                      /* Arbitration Lost */
;;;791                default:                                                        /* Unknow status */
;;;792                    I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;793                    u8Ctrl = I2C_CTL_SI;                                  /* Clear SI and send STOP */
000042  2308              MOVS     r3,#8
;;;794                    u8Err = 1;
;;;795                    break;
000044  e009              B        |L30.90|
                  |L30.70|
000046  4671              MOV      r1,lr                 ;760
000048  0049              LSLS     r1,r1,#1              ;760
00004a  6081              STR      r1,[r0,#8]            ;760
00004c  2308              MOVS     r3,#8                 ;761
00004e  e017              B        |L30.128|
                  |L30.80|
000050  4661              MOV      r1,r12                ;765
000052  0a0a              LSRS     r2,r1,#8              ;765
000054  6082              STR      r2,[r0,#8]            ;765
000056  e013              B        |L30.128|
                  |L30.88|
000058  2318              MOVS     r3,#0x18              ;770
                  |L30.90|
00005a  2501              MOVS     r5,#1                 ;771
00005c  e010              B        |L30.128|
                  |L30.94|
00005e  2e00              CMP      r6,#0                 ;775
000060  d004              BEQ      |L30.108|
000062  4661              MOV      r1,r12                ;777
000064  b2c9              UXTB     r1,r1                 ;777
000066  6081              STR      r1,[r0,#8]            ;777
000068  2600              MOVS     r6,#0                 ;778
00006a  e009              B        |L30.128|
                  |L30.108|
00006c  9a09              LDR      r2,[sp,#0x24]         ;780
00006e  4294              CMP      r4,r2                 ;780
000070  d204              BCS      |L30.124|
000072  9a03              LDR      r2,[sp,#0xc]          ;781
000074  5d12              LDRB     r2,[r2,r4]            ;781
000076  6082              STR      r2,[r0,#8]            ;781
000078  1c64              ADDS     r4,r4,#1              ;781
00007a  e001              B        |L30.128|
                  |L30.124|
00007c  2318              MOVS     r3,#0x18              ;784
00007e  2700              MOVS     r7,#0                 ;785
                  |L30.128|
;;;796            }
;;;797    
;;;798            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000080  6801              LDR      r1,[r0,#0]
000082  223c              MOVS     r2,#0x3c
000084  4391              BICS     r1,r1,r2
000086  460a              MOV      r2,r1
000088  431a              ORRS     r2,r2,r3
00008a  6002              STR      r2,[r0,#0]
00008c  2f00              CMP      r7,#0                 ;753
00008e  d001              BEQ      |L30.148|
000090  2d00              CMP      r5,#0                 ;753
000092  d0c1              BEQ      |L30.24|
                  |L30.148|
;;;799        }
;;;800    
;;;801        return u32txLen;                                                        /* Return bytes length that have been transmitted */
000094  4620              MOV      r0,r4
;;;802    }
000096  b004              ADD      sp,sp,#0x10
000098  bdf0              POP      {r4-r7,pc}
;;;803    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L187.16|
00000e  461d              MOV      r5,r3
                  |L187.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 479
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
