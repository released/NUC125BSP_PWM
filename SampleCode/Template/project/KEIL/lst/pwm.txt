; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\pwm.crf ..\..\..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;345      */
;;;346    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;347    {
;;;348        uint32_t u32PllFreq = 0, u32PllReg;
;;;349        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;350        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a012              ADR      r0,|L1.76|
000004  6800              LDR      r0,[r0,#0]
;;;351    
;;;352        u32PllReg = CLK->PLLCTL;
000006  9000              STR      r0,[sp,#0]
000008  4811              LDR      r0,|L1.80|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;353    
;;;354        if (u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;355            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;356    
;;;357        if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC_DIV2)
;;;358            u32FIN = __HIRC_DIV2;    /* PLL source clock from HIRC_DIV2 */
;;;359        else
;;;360            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;361    
;;;362        if (u32PllReg & CLK_PLLCTL_BP_Msk)
;;;363            return u32FIN;      /* PLL is in bypass mode */
;;;364    
;;;365        /* PLL is output enabled in normal work mode */
;;;366        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;367        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;368        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;369    
;;;370        /* u32FIN is shifted 2 bits to avoid overflow */
;;;371        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;372    
;;;373        return u32PllFreq;
;;;374    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  2011              MOVS     r0,#0x11              ;357
000018  04c0              LSLS     r0,r0,#19             ;357
00001a  4201              TST      r1,r0                 ;357
00001c  d001              BEQ      |L1.34|
00001e  480d              LDR      r0,|L1.84|
000020  e000              B        |L1.36|
                  |L1.34|
000022  480d              LDR      r0,|L1.88|
                  |L1.36|
000024  038a              LSLS     r2,r1,#14             ;362
000026  d4f5              BMI      |L1.20|
000028  040a              LSLS     r2,r1,#16             ;366
00002a  0f92              LSRS     r2,r2,#30             ;366
00002c  466b              MOV      r3,sp                 ;366
00002e  5c9b              LDRB     r3,[r3,r2]            ;366
000030  05ca              LSLS     r2,r1,#23             ;367
000032  0489              LSLS     r1,r1,#18             ;368
000034  0dd2              LSRS     r2,r2,#23             ;367
000036  0ec9              LSRS     r1,r1,#27             ;368
000038  1c89              ADDS     r1,r1,#2              ;368
00003a  0880              LSRS     r0,r0,#2              ;371
00003c  1c92              ADDS     r2,r2,#2              ;371
00003e  4359              MULS     r1,r3,r1              ;371
000040  4350              MULS     r0,r2,r0              ;371
000042  f7fffffe          BL       __aeabi_uidivmod
000046  0080              LSLS     r0,r0,#2              ;371
000048  bd08              POP      {r3,pc}
;;;375    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
00004c  01020204          DCB      1,2,2,4
                  |L1.80|
                          DCD      0x50000200
                  |L1.84|
                          DCD      0x016e3600
                  |L1.88|
                          DCD      0x00b71b00

                          AREA ||i.PWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearADCTriggerFlag PROC
;;;306     */
;;;307    void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  2201              MOVS     r2,#1
;;;308    {
;;;309        (void) u32Condition;
;;;310        (pwm)->STATUS = (PWM_STATUS_ADCTRG0_Msk << u32ChannelNum);
000002  0412              LSLS     r2,r2,#16
000004  408a              LSLS     r2,r2,r1
000006  30ff              ADDS     r0,r0,#0xff
000008  3001              ADDS     r0,#1
00000a  6202              STR      r2,[r0,#0x20]
;;;311    }
00000c  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearCaptureIntFlag PROC
;;;549     */
;;;550    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  408a              LSLS     r2,r2,r1
;;;551    {
;;;552        (pwm)->CAPIF = (u32Edge << u32ChannelNum);
000002  30ff              ADDS     r0,r0,#0xff
000004  30ff              ADDS     r0,r0,#0xff
000006  3002              ADDS     r0,#2
000008  6542              STR      r2,[r0,#0x54]
;;;553    }
00000a  4770              BX       lr
;;;554    
                          ENDP


                          AREA ||i.PWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearDutyIntFlag PROC
;;;611     */
;;;612    void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  4a02              LDR      r2,|L4.12|
;;;613    {
;;;614        (pwm)->INTSTS0 = (PWM_INTSTS0_CMPUIF0_Msk | PWM_INTSTS0_CMPDIF0_Msk) << u32ChannelNum;
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  6682              STR      r2,[r0,#0x68]
;;;615    }
000008  4770              BX       lr
;;;616    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x01010000

                          AREA ||i.PWM_ClearFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearFaultBrakeIntFlag PROC
;;;708     */
;;;709    void PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000000  223f              MOVS     r2,#0x3f
;;;710    {
;;;711        (pwm)->INTSTS1 = (0x3f << u32BrakeSource);
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  66c2              STR      r2,[r0,#0x6c]
;;;712    }
000008  4770              BX       lr
;;;713    
                          ENDP


                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearPeriodIntFlag PROC
;;;768     */
;;;769    void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;770    {
;;;771        (pwm)->INTSTS0 = (PWM_INTSTS0_PIF0_Msk << ((u32ChannelNum >> 1) << 1));
000002  0052              LSLS     r2,r2,#1
000004  21ff              MOVS     r1,#0xff
000006  3101              ADDS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  3080              ADDS     r0,r0,#0x80
00000c  6681              STR      r1,[r0,#0x68]
;;;772    }
00000e  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.PWM_ClearWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearWrapAroundFlag PROC
;;;976     */
;;;977    void PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;978    {
;;;979        (pwm)->STATUS = (PWM_STATUS_CNTMAX0_Msk << ((u32ChannelNum >> 1) << 1));
000002  0052              LSLS     r2,r2,#1
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  30ff              ADDS     r0,r0,#0xff
00000a  3001              ADDS     r0,#1
00000c  6201              STR      r1,[r0,#0x20]
;;;980    }
00000e  4770              BX       lr
;;;981    
                          ENDP


                          AREA ||i.PWM_ClearZeroIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearZeroIntFlag PROC
;;;826     */
;;;827    void PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;828    {
;;;829        (pwm)->INTSTS0 = (PWM_INTSTS0_ZIF0_Msk << ((u32ChannelNum >> 1) << 1));
000002  0052              LSLS     r2,r2,#1
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  3080              ADDS     r0,r0,#0x80
00000a  6681              STR      r1,[r0,#0x68]
;;;830    }
00000c  4770              BX       lr
;;;831    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;34      */
;;;35     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge)
000000  b5ff              PUSH     {r0-r7,lr}
;;;36     {
000002  4605              MOV      r5,r0
000004  b081              SUB      sp,sp,#4
;;;37         uint32_t u32Src;
;;;38         uint32_t u32PWMClockSrc;
;;;39         uint32_t u32NearestUnitTimeNsec;
;;;40         uint16_t u16Prescale = 1, u16CNR = 0xFFFF;
000006  4824              LDR      r0,|L9.152|
;;;41     
;;;42         (void) u32CaptureEdge;
;;;43     
;;;44         if (pwm == PWM0)
;;;45             u32Src = CLK->CLKSEL1 & CLK_CLKSEL1_PWM0SEL_Msk;
000008  9000              STR      r0,[sp,#0]
00000a  4825              LDR      r0,|L9.160|
00000c  4923              LDR      r1,|L9.156|
00000e  2401              MOVS     r4,#1                 ;40
;;;46         else//(pwm == PWM1)
;;;47             u32Src = CLK->CLKSEL1 & CLK_CLKSEL1_PWM1SEL_Msk;
000010  6940              LDR      r0,[r0,#0x14]
000012  428d              CMP      r5,r1                 ;44
000014  d102              BNE      |L9.28|
000016  0409              LSLS     r1,r1,#16             ;45
000018  4008              ANDS     r0,r0,r1              ;45
00001a  e001              B        |L9.32|
                  |L9.28|
00001c  0fc0              LSRS     r0,r0,#31
00001e  07c0              LSLS     r0,r0,#31
                  |L9.32|
;;;48     
;;;49         if (u32Src == 0)
000020  2800              CMP      r0,#0
000022  d035              BEQ      |L9.144|
;;;50         {
;;;51             //clock source is from PLL clock
;;;52             u32PWMClockSrc = CLK_GetPLLClockFreq();
;;;53         }
;;;54         else
;;;55         {
;;;56             //clock source is from PCLK
;;;57             SystemCoreClockUpdate();
000024  f7fffffe          BL       SystemCoreClockUpdate
;;;58             u32PWMClockSrc = SystemCoreClock;
000028  481e              LDR      r0,|L9.164|
00002a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
                  |L9.44|
;;;59         }
;;;60     
;;;61         u32PWMClockSrc /= 1000;
00002c  217d              MOVS     r1,#0x7d
00002e  00c9              LSLS     r1,r1,#3
000030  f7fffffe          BL       __aeabi_uidivmod
;;;62     
;;;63         for (u16Prescale = 1; u16Prescale <= 0x1000; u16Prescale++)
;;;64         {
;;;65             u32NearestUnitTimeNsec = (1000000 * u16Prescale) / u32PWMClockSrc;
;;;66     
;;;67             if (u32NearestUnitTimeNsec < u32UnitTimeNsec)
;;;68             {
;;;69                 if (u16Prescale == 0x1000) //limit to the maximum unit time(nano second)
000034  2601              MOVS     r6,#1
000036  4607              MOV      r7,r0                 ;61
000038  0336              LSLS     r6,r6,#12
                  |L9.58|
00003a  491b              LDR      r1,|L9.168|
00003c  4620              MOV      r0,r4                 ;65
00003e  4348              MULS     r0,r1,r0              ;65
000040  4639              MOV      r1,r7                 ;65
000042  f7fffffe          BL       __aeabi_uidivmod
000046  9903              LDR      r1,[sp,#0xc]          ;67
000048  4288              CMP      r0,r1                 ;67
00004a  d20c              BCS      |L9.102|
00004c  42b4              CMP      r4,r6
00004e  d00a              BEQ      |L9.102|
;;;70                     break;
;;;71     
;;;72                 if (!((1000000UL * (u16Prescale + 1) > (u32NearestUnitTimeNsec * u32PWMClockSrc))))
000050  1c61              ADDS     r1,r4,#1
000052  4b15              LDR      r3,|L9.168|
000054  460a              MOV      r2,r1
000056  435a              MULS     r2,r3,r2
000058  4603              MOV      r3,r0
00005a  437b              MULS     r3,r7,r3
00005c  429a              CMP      r2,r3
00005e  d902              BLS      |L9.102|
000060  b28c              UXTH     r4,r1                 ;63
000062  42b4              CMP      r4,r6                 ;63
000064  d9e9              BLS      |L9.58|
                  |L9.102|
;;;73                     break;
;;;74     
;;;75                 continue;
;;;76             }
;;;77     
;;;78             break;
;;;79         }
;;;80     
;;;81         // convert to real register value
;;;82         // every two channels share a prescaler
;;;83         PWM_SET_PRESCALER(pwm, u32ChannelNum, --u16Prescale);
000066  9902              LDR      r1,[sp,#8]
000068  1e64              SUBS     r4,r4,#1              ;63
00006a  084a              LSRS     r2,r1,#1
00006c  b2a3              UXTH     r3,r4
00006e  0091              LSLS     r1,r2,#2
000070  194c              ADDS     r4,r1,r5
000072  6163              STR      r3,[r4,#0x14]
;;;84     
;;;85         // set PWM to down count type(edge aligned)
;;;86         (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << ((u32ChannelNum >> 1) << 2))) | (1UL << ((u32ChannelNum >> 1) << 2));
000074  686b              LDR      r3,[r5,#4]
000076  2403              MOVS     r4,#3
000078  408c              LSLS     r4,r4,r1
00007a  43a3              BICS     r3,r3,r4
00007c  2401              MOVS     r4,#1
00007e  408c              LSLS     r4,r4,r1
000080  4323              ORRS     r3,r3,r4
000082  606b              STR      r3,[r5,#4]
;;;87     
;;;88         PWM_SET_CNR(pwm, u32ChannelNum, u16CNR);
000084  00d2              LSLS     r2,r2,#3
000086  1952              ADDS     r2,r2,r5
000088  9900              LDR      r1,[sp,#0]
00008a  6311              STR      r1,[r2,#0x30]
;;;89     
;;;90         return (u32NearestUnitTimeNsec);
;;;91     }
00008c  b005              ADD      sp,sp,#0x14
00008e  bdf0              POP      {r4-r7,pc}
                  |L9.144|
000090  f7fffffe          BL       CLK_GetPLLClockFreq
000094  e7ca              B        |L9.44|
;;;92     
                          ENDP

000096  0000              DCW      0x0000
                  |L9.152|
                          DCD      0x0000ffff
                  |L9.156|
                          DCD      0x40044000
                  |L9.160|
                          DCD      0x50000200
                  |L9.164|
                          DCD      SystemCoreClock
                  |L9.168|
                          DCD      0x000f4240

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;104     */
;;;105    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle)
000000  b5ff              PUSH     {r0-r7,lr}
;;;106    {
000002  4604              MOV      r4,r0
;;;107        uint32_t u32Src;
;;;108        uint32_t u32PWMClockSrc;
;;;109        uint32_t i;
;;;110        uint16_t u16Prescale = 1, u16CNR = 0xFFFF;
;;;111    
;;;112        if (pwm == PWM0)
;;;113            u32Src = CLK->CLKSEL1 & CLK_CLKSEL1_PWM0SEL_Msk;
000004  4841              LDR      r0,|L10.268|
000006  4940              LDR      r1,|L10.264|
000008  2501              MOVS     r5,#1                 ;110
00000a  4e3e              LDR      r6,|L10.260|
;;;114        else//(pwm == PWM1)
;;;115            u32Src = CLK->CLKSEL1 & CLK_CLKSEL1_PWM1SEL_Msk;
00000c  6940              LDR      r0,[r0,#0x14]
00000e  b083              SUB      sp,sp,#0xc            ;106
000010  461f              MOV      r7,r3                 ;106
000012  428c              CMP      r4,r1                 ;112
000014  d102              BNE      |L10.28|
000016  0409              LSLS     r1,r1,#16             ;113
000018  4008              ANDS     r0,r0,r1              ;113
00001a  e001              B        |L10.32|
                  |L10.28|
00001c  0fc0              LSRS     r0,r0,#31
00001e  07c0              LSLS     r0,r0,#31
                  |L10.32|
;;;116    
;;;117        if (u32Src == 0)
000020  2800              CMP      r0,#0
000022  d011              BEQ      |L10.72|
;;;118        {
;;;119            //clock source is from PLL clock
;;;120            u32PWMClockSrc = CLK_GetPLLClockFreq();
;;;121        }
;;;122        else
;;;123        {
;;;124            //clock source is from PCLK
;;;125            SystemCoreClockUpdate();
000024  f7fffffe          BL       SystemCoreClockUpdate
;;;126            u32PWMClockSrc = SystemCoreClock;
000028  4839              LDR      r0,|L10.272|
00002a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
                  |L10.44|
00002c  9000              STR      r0,[sp,#0]            ;106
;;;127        }
;;;128    
;;;129        for (u16Prescale = 1; u16Prescale < 0xFFF; u16Prescale++)   //prescale could be 0~0xFFF
;;;130        {
;;;131            i = (u32PWMClockSrc / u32Frequency) / u16Prescale;
00002e  9905              LDR      r1,[sp,#0x14]
000030  f7fffffe          BL       __aeabi_uidivmod
000034  9001              STR      r0,[sp,#4]
                  |L10.54|
000036  4629              MOV      r1,r5
000038  f7fffffe          BL       __aeabi_uidivmod
;;;132    
;;;133            // If target value is larger than CNR, need to use a larger prescaler
;;;134            if (i > (0x10000))
00003c  2101              MOVS     r1,#1
00003e  0409              LSLS     r1,r1,#16
000040  4288              CMP      r0,r1
000042  d804              BHI      |L10.78|
;;;135                continue;
;;;136    
;;;137            u16CNR = i;
000044  b286              UXTH     r6,r0
;;;138            break;
000046  e009              B        |L10.92|
                  |L10.72|
000048  f7fffffe          BL       CLK_GetPLLClockFreq
00004c  e7ee              B        |L10.44|
                  |L10.78|
00004e  1c6d              ADDS     r5,r5,#1              ;120
000050  4830              LDR      r0,|L10.276|
000052  b2ad              UXTH     r5,r5                 ;129
000054  4285              CMP      r5,r0                 ;129
000056  d201              BCS      |L10.92|
000058  9801              LDR      r0,[sp,#4]            ;129
00005a  e7ec              B        |L10.54|
                  |L10.92|
;;;139        }
;;;140    
;;;141        // Store return value here 'cos we're gonna change u16Prescale & u16CNR to the real value to fill into register
;;;142        i = u32PWMClockSrc / (u16Prescale * u16CNR);
00005c  4629              MOV      r1,r5
00005e  4371              MULS     r1,r6,r1
000060  9800              LDR      r0,[sp,#0]
000062  f7fffffe          BL       __aeabi_uidivmod
;;;143    
;;;144        // convert to real register value
;;;145        // every two channels share a prescaler
;;;146        PWM_SET_PRESCALER(pwm, u32ChannelNum, --u16Prescale);
000066  9002              STR      r0,[sp,#8]
000068  9804              LDR      r0,[sp,#0x10]
00006a  1e6d              SUBS     r5,r5,#1              ;142
00006c  0842              LSRS     r2,r0,#1
00006e  0090              LSLS     r0,r2,#2
000070  b2a9              UXTH     r1,r5
000072  1903              ADDS     r3,r0,r4
000074  6159              STR      r1,[r3,#0x14]
;;;147        // set PWM to down count type(edge aligned)
;;;148        (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << ((u32ChannelNum >> 1) << 2))) | (1UL << ((u32ChannelNum >> 1) << 2));
000076  6861              LDR      r1,[r4,#4]
000078  2303              MOVS     r3,#3
00007a  4083              LSLS     r3,r3,r0
00007c  4399              BICS     r1,r1,r3
00007e  2301              MOVS     r3,#1
000080  4083              LSLS     r3,r3,r0
000082  4319              ORRS     r1,r1,r3
000084  6061              STR      r1,[r4,#4]
000086  1e76              SUBS     r6,r6,#1
;;;149    
;;;150        PWM_SET_CNR(pwm, u32ChannelNum, --u16CNR);
000088  00d0              LSLS     r0,r2,#3
00008a  b2b1              UXTH     r1,r6
00008c  1900              ADDS     r0,r0,r4
00008e  6301              STR      r1,[r0,#0x30]
;;;151    
;;;152        if (u32DutyCycle)
;;;153        {
;;;154            if (u32DutyCycle >= 100)
;;;155                PWM_SET_CMR(pwm, u32ChannelNum, u16CNR);
000090  9804              LDR      r0,[sp,#0x10]
;;;156            else
;;;157                PWM_SET_CMR(pwm, u32ChannelNum, u32DutyCycle * (u16CNR + 1) / 100);
;;;158    
;;;159            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum * 2));
;;;160            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << (u32ChannelNum * 2 + PWM_WGCTL0_PRDPCTL0_Pos));
;;;161            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum * 2));
;;;162            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << (u32ChannelNum * 2 + PWM_WGCTL1_CMPDCTL0_Pos));
000092  2302              MOVS     r3,#2
000094  0080              LSLS     r0,r0,#2              ;155
000096  1906              ADDS     r6,r0,r4              ;155
000098  9804              LDR      r0,[sp,#0x10]         ;159
00009a  4d1f              LDR      r5,|L10.280|
00009c  0040              LSLS     r0,r0,#1              ;159
00009e  4602              MOV      r2,r0                 ;160
0000a0  3210              ADDS     r2,r2,#0x10           ;160
0000a2  4093              LSLS     r3,r3,r2
0000a4  4085              LSLS     r5,r5,r0              ;159
0000a6  3480              ADDS     r4,r4,#0x80           ;159
0000a8  9300              STR      r3,[sp,#0]            ;152
0000aa  9201              STR      r2,[sp,#4]            ;152
0000ac  2f00              CMP      r7,#0                 ;152
0000ae  d01d              BEQ      |L10.236|
0000b0  2f64              CMP      r7,#0x64              ;154
0000b2  d301              BCC      |L10.184|
0000b4  6531              STR      r1,[r6,#0x50]         ;155
0000b6  e006              B        |L10.198|
                  |L10.184|
0000b8  4638              MOV      r0,r7                 ;155
0000ba  1c49              ADDS     r1,r1,#1              ;155
0000bc  4348              MULS     r0,r1,r0              ;157
0000be  2164              MOVS     r1,#0x64              ;157
0000c0  f7fffffe          BL       __aeabi_uidivmod
0000c4  6530              STR      r0,[r6,#0x50]         ;157
                  |L10.198|
0000c6  6b20              LDR      r0,[r4,#0x30]         ;159
0000c8  43a8              BICS     r0,r0,r5              ;159
0000ca  6320              STR      r0,[r4,#0x30]         ;159
0000cc  6b21              LDR      r1,[r4,#0x30]         ;160
0000ce  9a01              LDR      r2,[sp,#4]            ;160
0000d0  2001              MOVS     r0,#1                 ;160
0000d2  4090              LSLS     r0,r0,r2              ;160
0000d4  4301              ORRS     r1,r1,r0              ;160
0000d6  6321              STR      r1,[r4,#0x30]         ;160
                  |L10.216|
;;;163        }
;;;164        else
;;;165        {
;;;166            PWM_SET_CMR(pwm, u32ChannelNum, 0);
;;;167            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum * 2));
;;;168            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << (u32ChannelNum * 2 + PWM_WGCTL0_ZPCTL0_Pos));
;;;169            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum * 2));
0000d8  6b60              LDR      r0,[r4,#0x34]
0000da  43a8              BICS     r0,r0,r5
0000dc  6360              STR      r0,[r4,#0x34]
;;;170            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << (u32ChannelNum * 2 + PWM_WGCTL1_CMPDCTL0_Pos));
0000de  6b60              LDR      r0,[r4,#0x34]
0000e0  9900              LDR      r1,[sp,#0]
0000e2  4308              ORRS     r0,r0,r1
0000e4  6360              STR      r0,[r4,#0x34]
;;;171        }
;;;172    
;;;173        return (i);
0000e6  9802              LDR      r0,[sp,#8]
;;;174    }
0000e8  b007              ADD      sp,sp,#0x1c
0000ea  bdf0              POP      {r4-r7,pc}
                  |L10.236|
0000ec  2100              MOVS     r1,#0                 ;166
0000ee  6531              STR      r1,[r6,#0x50]         ;166
0000f0  6b21              LDR      r1,[r4,#0x30]         ;167
0000f2  43a9              BICS     r1,r1,r5              ;167
0000f4  6321              STR      r1,[r4,#0x30]         ;167
0000f6  6b22              LDR      r2,[r4,#0x30]         ;168
0000f8  2101              MOVS     r1,#1                 ;168
0000fa  4081              LSLS     r1,r1,r0              ;168
0000fc  430a              ORRS     r2,r2,r1              ;168
0000fe  6322              STR      r2,[r4,#0x30]         ;168
000100  e7ea              B        |L10.216|
;;;175    
                          ENDP

000102  0000              DCW      0x0000
                  |L10.260|
                          DCD      0x0000ffff
                  |L10.264|
                          DCD      0x40044000
                  |L10.268|
                          DCD      0x50000200
                  |L10.272|
                          DCD      SystemCoreClock
                  |L10.276|
                          DCD      0x00000fff
                  |L10.280|
                          DCD      0x00030003

                          AREA ||i.PWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_DisableADCTrigger PROC
;;;284     */
;;;285    void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
000000  00ca              LSLS     r2,r1,#3
;;;286    {
;;;287        if (u32ChannelNum < 4)
;;;288        {
;;;289            (pwm)->ADCTS0 &= ~(PWM_ADCTS0_TRGEN0_Msk << (u32ChannelNum * 8));
000002  2380              MOVS     r3,#0x80
000004  3080              ADDS     r0,r0,#0x80
000006  2904              CMP      r1,#4                 ;287
000008  d204              BCS      |L11.20|
00000a  6f81              LDR      r1,[r0,#0x78]
00000c  4093              LSLS     r3,r3,r2
00000e  4399              BICS     r1,r1,r3
000010  6781              STR      r1,[r0,#0x78]
;;;290        }
;;;291        else
;;;292        {
;;;293            (pwm)->ADCTS1 &= ~(PWM_ADCTS1_TRGEN4_Msk << ((u32ChannelNum - 4) * 8));
;;;294        }
;;;295    }
000012  4770              BX       lr
                  |L11.20|
000014  3a20              SUBS     r2,r2,#0x20
000016  6fc1              LDR      r1,[r0,#0x7c]         ;293
000018  4093              LSLS     r3,r3,r2              ;293
00001a  4399              BICS     r1,r1,r3              ;293
00001c  67c1              STR      r1,[r0,#0x7c]         ;293
00001e  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.PWM_DisableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  PWM_DisableBrakeNoiseFilter PROC
;;;903     */
;;;904    void PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;905    {
;;;906        (pwm)->BNF &= ~(PWM_BNF_BRK0FEN_Msk << (u32BrakePinNum * PWM_BNF_BRK1FEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2101              MOVS     r1,#1
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;907    }
00000e  4770              BX       lr
;;;908    
                          ENDP


                          AREA ||i.PWM_DisableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  PWM_DisableBrakePinInverse PROC
;;;931     */
;;;932    void PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;933    {
;;;934        (pwm)->BNF &= ~(PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1FEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;935    }
00000e  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;432     */
;;;433    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  30ff              ADDS     r0,r0,#0xff
;;;434    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;435        (pwm)->CAPINEN &= ~u32ChannelMask;
000006  6802              LDR      r2,[r0,#0]
000008  438a              BICS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;436        (pwm)->CAPCTL &= ~u32ChannelMask;
00000c  6842              LDR      r2,[r0,#4]
00000e  438a              BICS     r2,r2,r1
000010  6042              STR      r2,[r0,#4]
;;;437    }
000012  4770              BX       lr
;;;438    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;532     */
;;;533    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  30ff              ADDS     r0,r0,#0xff
;;;534    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;535        (pwm)->CAPIEN &= ~(u32Edge << u32ChannelNum);
000006  6d03              LDR      r3,[r0,#0x50]
000008  408a              LSLS     r2,r2,r1
00000a  4393              BICS     r3,r3,r2
00000c  6503              STR      r3,[r0,#0x50]
;;;536    }
00000e  4770              BX       lr
;;;537    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;497     */
;;;498    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
000000  0849              LSRS     r1,r1,#1
;;;499    {
;;;500        // every two channels shares the same setting
;;;501        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) &= ~PWM_DTCTL0_1_DTEN_Msk;
000002  0089              LSLS     r1,r1,#2
000004  1808              ADDS     r0,r1,r0
000006  6f01              LDR      r1,[r0,#0x70]
000008  2201              MOVS     r2,#1
00000a  0412              LSLS     r2,r2,#16
00000c  4391              BICS     r1,r1,r2
00000e  6701              STR      r1,[r0,#0x70]
;;;502    }
000010  4770              BX       lr
;;;503    
                          ENDP


                          AREA ||i.PWM_DisableDutyInt||, CODE, READONLY, ALIGN=2

                  PWM_DisableDutyInt PROC
;;;597     */
;;;598    void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;599    {
;;;600        (pwm)->INTEN0 &= ~((PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP | PWM_DUTY_INT_UP_COUNT_MATCH_CMP) << u32ChannelNum);
000002  6e02              LDR      r2,[r0,#0x60]
000004  4b02              LDR      r3,|L17.16|
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6602              STR      r2,[r0,#0x60]
;;;601    }
00000c  4770              BX       lr
;;;602    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x01010000

                          AREA ||i.PWM_DisableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableFaultBrakeInt PROC
;;;693     */
;;;694    void PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;695    {
;;;696        (pwm)->INTEN1 &= ~(0x7 << u32BrakeSource);
000002  6e42              LDR      r2,[r0,#0x64]
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6642              STR      r2,[r0,#0x64]
;;;697    }
00000c  4770              BX       lr
;;;698    
                          ENDP


                          AREA ||i.PWM_DisableLoadMode||, CODE, READONLY, ALIGN=1

                  PWM_DisableLoadMode PROC
;;;661     */
;;;662    void PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;663    {
;;;664        (pwm)->CTL0 &= ~(u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4393              BICS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;665    }
000008  4770              BX       lr
;;;666    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;463     */
;;;464    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  3080              ADDS     r0,r0,#0x80
;;;465    {
;;;466        (pwm)->POEN &= ~u32ChannelMask;
000002  6d82              LDR      r2,[r0,#0x58]
000004  438a              BICS     r2,r2,r1
000006  6582              STR      r2,[r0,#0x58]
;;;467    }
000008  4770              BX       lr
;;;468    
                          ENDP


                          AREA ||i.PWM_DisablePDMA||, CODE, READONLY, ALIGN=1

                  PWM_DisablePDMA PROC
;;;1014    */
;;;1015   void PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;1016   {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;1017       (pwm)->PDMACTL &= ~(PWM_PDMACTL_CHEN0_1_Msk << ((u32ChannelNum >> 1) * 8));
000006  6bc2              LDR      r2,[r0,#0x3c]
000008  0849              LSRS     r1,r1,#1
00000a  00cb              LSLS     r3,r1,#3
00000c  2101              MOVS     r1,#1
00000e  4099              LSLS     r1,r1,r3
000010  438a              BICS     r2,r2,r1
000012  63c2              STR      r2,[r0,#0x3c]
;;;1018   }
000014  4770              BX       lr
;;;1019   
                          ENDP


                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;754     */
;;;755    void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;756    {
;;;757        (pwm)->INTEN0 &= ~(PWM_INTEN0_PIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4099              LSLS     r1,r1,r3
00000e  438a              BICS     r2,r2,r1
000010  6602              STR      r2,[r0,#0x60]
;;;758    }
000012  4770              BX       lr
;;;759    
                          ENDP


                          AREA ||i.PWM_DisableZeroInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableZeroInt PROC
;;;812     */
;;;813    void PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;814    {
;;;815        (pwm)->INTEN0 &= ~(PWM_INTEN0_ZIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  438a              BICS     r2,r2,r1
00000e  6602              STR      r2,[r0,#0x60]
;;;816    }
000010  4770              BX       lr
;;;817    
                          ENDP


                          AREA ||i.PWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_EnableADCTrigger PROC
;;;261     */
;;;262    void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b510              PUSH     {r4,lr}
;;;263    {
;;;264        if (u32ChannelNum < 4)
;;;265        {
;;;266            (pwm)->ADCTS0 &= ~((PWM_ADCTS0_TRGSEL0_Msk) << (u32ChannelNum * 8));
;;;267            (pwm)->ADCTS0 |= ((PWM_ADCTS0_TRGEN0_Msk | u32Condition) << (u32ChannelNum * 8));
000002  2380              MOVS     r3,#0x80
000004  431a              ORRS     r2,r2,r3
000006  240f              MOVS     r4,#0xf               ;266
000008  00cb              LSLS     r3,r1,#3              ;266
00000a  3080              ADDS     r0,r0,#0x80           ;266
00000c  2904              CMP      r1,#4                 ;264
00000e  d208              BCS      |L24.34|
000010  6f81              LDR      r1,[r0,#0x78]         ;266
000012  409c              LSLS     r4,r4,r3              ;266
000014  43a1              BICS     r1,r1,r4              ;266
000016  6781              STR      r1,[r0,#0x78]         ;266
000018  6f81              LDR      r1,[r0,#0x78]
00001a  409a              LSLS     r2,r2,r3
00001c  430a              ORRS     r2,r2,r1
00001e  6782              STR      r2,[r0,#0x78]
;;;268        }
;;;269        else
;;;270        {
;;;271            (pwm)->ADCTS1 &= ~((PWM_ADCTS1_TRGSEL4_Msk) << ((u32ChannelNum - 4) * 8));
;;;272            (pwm)->ADCTS1 |= ((PWM_ADCTS1_TRGEN4_Msk | u32Condition) << ((u32ChannelNum - 4) * 8));
;;;273        }
;;;274    }
000020  bd10              POP      {r4,pc}
                  |L24.34|
000022  3b20              SUBS     r3,r3,#0x20
000024  6fc1              LDR      r1,[r0,#0x7c]         ;271
000026  409c              LSLS     r4,r4,r3              ;271
000028  43a1              BICS     r1,r1,r4              ;271
00002a  67c1              STR      r1,[r0,#0x7c]         ;271
00002c  6fc1              LDR      r1,[r0,#0x7c]         ;272
00002e  409a              LSLS     r2,r2,r3              ;272
000030  430a              ORRS     r2,r2,r1              ;272
000032  67c2              STR      r2,[r0,#0x7c]         ;272
000034  bd10              POP      {r4,pc}
;;;275    
                          ENDP


                          AREA ||i.PWM_EnableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  PWM_EnableBrakeNoiseFilter PROC
;;;888     */
;;;889    void PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
000000  b530              PUSH     {r4,r5,lr}
;;;890    {
000002  3080              ADDS     r0,r0,#0x80
;;;891        (pwm)->BNF = ((pwm)->BNF & ~((PWM_BNF_BRK0FCNT_Msk | PWM_BNF_BRK0FCS_Msk) << (u32BrakePinNum * PWM_BNF_BRK1FEN_Pos))) | \
000004  6c04              LDR      r4,[r0,#0x40]
000006  00c9              LSLS     r1,r1,#3
000008  257e              MOVS     r5,#0x7e
00000a  408d              LSLS     r5,r5,r1
00000c  0112              LSLS     r2,r2,#4
00000e  005b              LSLS     r3,r3,#1
000010  431a              ORRS     r2,r2,r3
000012  1c52              ADDS     r2,r2,#1
000014  43ac              BICS     r4,r4,r5
000016  408a              LSLS     r2,r2,r1
000018  4314              ORRS     r4,r4,r2
00001a  6404              STR      r4,[r0,#0x40]
;;;892                     (((u32ClkCnt << PWM_BNF_BRK0FCNT_Pos) | (u32ClkDivSel << PWM_BNF_BRK0FCS_Pos) | PWM_BNF_BRK0FEN_Msk) << (u32BrakePinNum * PWM_BNF_BRK1FEN_Pos));
;;;893    }
00001c  bd30              POP      {r4,r5,pc}
;;;894    
                          ENDP


                          AREA ||i.PWM_EnableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  PWM_EnableBrakePinInverse PROC
;;;917     */
;;;918    void PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;919    {
;;;920        (pwm)->BNF |= (PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1FEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  430a              ORRS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;921    }
00000e  4770              BX       lr
;;;922    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;416     */
;;;417    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  30ff              ADDS     r0,r0,#0xff
;;;418    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;419        (pwm)->CAPINEN |= u32ChannelMask;
000006  6802              LDR      r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;420        (pwm)->CAPCTL |= u32ChannelMask;
00000c  6842              LDR      r2,[r0,#4]
00000e  430a              ORRS     r2,r2,r1
000010  6042              STR      r2,[r0,#4]
;;;421    }
000012  4770              BX       lr
;;;422    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;515     */
;;;516    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  30ff              ADDS     r0,r0,#0xff
;;;517    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;518        (pwm)->CAPIEN |= (u32Edge << u32ChannelNum);
000006  6d03              LDR      r3,[r0,#0x50]
000008  408a              LSLS     r2,r2,r1
00000a  4313              ORRS     r3,r3,r2
00000c  6503              STR      r3,[r0,#0x50]
;;;519    }
00000e  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;480     */
;;;481    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  0849              LSRS     r1,r1,#1
;;;482    {
;;;483        // every two channels share the same setting
;;;484        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) &= ~PWM_DTCTL0_1_DTCNT_Msk;
000002  0089              LSLS     r1,r1,#2
000004  1808              ADDS     r0,r1,r0
000006  6f01              LDR      r1,[r0,#0x70]
000008  0b09              LSRS     r1,r1,#12
00000a  0309              LSLS     r1,r1,#12
00000c  6701              STR      r1,[r0,#0x70]
;;;485        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) |= PWM_DTCTL0_1_DTEN_Msk | u32Duration;
00000e  6f01              LDR      r1,[r0,#0x70]
000010  2301              MOVS     r3,#1
000012  041b              LSLS     r3,r3,#16
000014  431a              ORRS     r2,r2,r3
000016  4311              ORRS     r1,r1,r2
000018  6701              STR      r1,[r0,#0x70]
;;;486    }
00001a  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.PWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableDutyInt PROC
;;;583     */
;;;584    void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  3080              ADDS     r0,r0,#0x80
;;;585    {
;;;586        (pwm)->INTEN0 |= (u32IntDutyType << u32ChannelNum);
000002  6e03              LDR      r3,[r0,#0x60]
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6603              STR      r3,[r0,#0x60]
;;;587    }
00000a  4770              BX       lr
;;;588    
                          ENDP


                          AREA ||i.PWM_EnableFaultBrake||, CODE, READONLY, ALIGN=2

                  PWM_EnableFaultBrake PROC
;;;350     */
;;;351    void PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource)
000000  b5f0              PUSH     {r4-r7,lr}
;;;352    {
000002  4696              MOV      lr,r2
;;;353        uint32_t i;
;;;354    
;;;355        for (i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  2400              MOVS     r4,#0
;;;356        {
;;;357            if (u32ChannelMask & (1 << i))
;;;358            {
;;;359                if ((u32BrakeSource == PWM_FB_EDGE_SYS_CSS) || (u32BrakeSource == PWM_FB_EDGE_SYS_BOD) || \
;;;360                        (u32BrakeSource == PWM_FB_EDGE_SYS_COR) || \
;;;361                        (u32BrakeSource == PWM_FB_LEVEL_SYS_CSS) || (u32BrakeSource == PWM_FB_LEVEL_SYS_BOD) || \
;;;362                        (u32BrakeSource == PWM_FB_LEVEL_SYS_COR))
;;;363                {
;;;364                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= (u32BrakeSource & (PWM_BRKCTL0_1_SYSEEN_Msk | PWM_BRKCTL0_1_SYSLEN_Msk));
;;;365                    (pwm)->FAILBRK |= (u32BrakeSource & 0xB);
;;;366                }
;;;367                else
;;;368                {
;;;369                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= u32BrakeSource;
;;;370                }
;;;371            }
;;;372    
;;;373            if (u32LevelMask & (1 << i))
;;;374            {
;;;375                if (i % 2 == 0)
;;;376                {
;;;377                    //set brake action as high level for even channel
;;;378                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
000006  2203              MOVS     r2,#3
000008  468c              MOV      r12,r1                ;352
00000a  0412              LSLS     r2,r2,#16
                  |L31.12|
00000c  2501              MOVS     r5,#1                 ;357
00000e  40a5              LSLS     r5,r5,r4              ;357
000010  4661              MOV      r1,r12                ;357
000012  420d              TST      r5,r1                 ;357
000014  d027              BEQ      |L31.102|
000016  2b81              CMP      r3,#0x81              ;359
000018  d00c              BEQ      |L31.52|
00001a  2b82              CMP      r3,#0x82              ;359
00001c  d00a              BEQ      |L31.52|
00001e  2b88              CMP      r3,#0x88              ;360
000020  d008              BEQ      |L31.52|
000022  492e              LDR      r1,|L31.220|
000024  428b              CMP      r3,r1                 ;361
000026  d005              BEQ      |L31.52|
000028  1c49              ADDS     r1,r1,#1              ;361
00002a  428b              CMP      r3,r1                 ;361
00002c  d002              BEQ      |L31.52|
00002e  1d89              ADDS     r1,r1,#6              ;362
000030  428b              CMP      r3,r1                 ;362
000032  d111              BNE      |L31.88|
                  |L31.52|
000034  0861              LSRS     r1,r4,#1              ;364
000036  0089              LSLS     r1,r1,#2              ;364
000038  180e              ADDS     r6,r1,r0              ;364
00003a  3680              ADDS     r6,r6,#0x80           ;364
00003c  6cb7              LDR      r7,[r6,#0x48]         ;364
00003e  4927              LDR      r1,|L31.220|
000040  317f              ADDS     r1,r1,#0x7f           ;364
000042  4019              ANDS     r1,r1,r3              ;364
000044  430f              ORRS     r7,r7,r1              ;364
000046  64b7              STR      r7,[r6,#0x48]         ;364
000048  4606              MOV      r6,r0                 ;365
00004a  3680              ADDS     r6,r6,#0x80           ;365
00004c  6c77              LDR      r7,[r6,#0x44]         ;365
00004e  210b              MOVS     r1,#0xb               ;365
000050  4019              ANDS     r1,r1,r3              ;365
000052  430f              ORRS     r7,r7,r1              ;365
000054  6477              STR      r7,[r6,#0x44]         ;365
000056  e006              B        |L31.102|
                  |L31.88|
000058  0861              LSRS     r1,r4,#1              ;369
00005a  0089              LSLS     r1,r1,#2              ;369
00005c  1809              ADDS     r1,r1,r0              ;369
00005e  3180              ADDS     r1,r1,#0x80           ;369
000060  6c8e              LDR      r6,[r1,#0x48]         ;369
000062  431e              ORRS     r6,r6,r3              ;369
000064  648e              STR      r6,[r1,#0x48]         ;369
                  |L31.102|
000066  4671              MOV      r1,lr                 ;373
000068  420d              TST      r5,r1                 ;373
00006a  d018              BEQ      |L31.158|
00006c  07e1              LSLS     r1,r4,#31             ;375
00006e  d00c              BEQ      |L31.138|
;;;379                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((3UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;380                }
;;;381                else
;;;382                {
;;;383                    //set brake action as high level for odd channel
;;;384                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
000070  0861              LSRS     r1,r4,#1
000072  0089              LSLS     r1,r1,#2
000074  180d              ADDS     r5,r1,r0
000076  3580              ADDS     r5,r5,#0x80
000078  6caf              LDR      r7,[r5,#0x48]
00007a  2603              MOVS     r6,#3
00007c  04b6              LSLS     r6,r6,#18
00007e  43b7              BICS     r7,r7,r6
000080  64af              STR      r7,[r5,#0x48]
;;;385                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((3UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
000082  6ca9              LDR      r1,[r5,#0x48]
000084  4331              ORRS     r1,r1,r6
000086  64a9              STR      r1,[r5,#0x48]
000088  e019              B        |L31.190|
                  |L31.138|
00008a  0861              LSRS     r1,r4,#1              ;378
00008c  0089              LSLS     r1,r1,#2              ;378
00008e  1809              ADDS     r1,r1,r0              ;378
000090  3180              ADDS     r1,r1,#0x80           ;378
000092  6c8d              LDR      r5,[r1,#0x48]         ;378
000094  4395              BICS     r5,r5,r2              ;378
000096  648d              STR      r5,[r1,#0x48]         ;378
000098  6c8d              LDR      r5,[r1,#0x48]         ;379
00009a  4315              ORRS     r5,r5,r2              ;379
00009c  e00e              B        |L31.188|
                  |L31.158|
;;;386                }
;;;387            }
;;;388            else
;;;389            {
;;;390                if (i % 2 == 0)
00009e  07e1              LSLS     r1,r4,#31
0000a0  d011              BEQ      |L31.198|
;;;391                {
;;;392                    //set brake action as low level for even channel
;;;393                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
;;;394                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((2UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;395                }
;;;396                else
;;;397                {
;;;398                    //set brake action as low level for odd channel
;;;399                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
0000a2  0861              LSRS     r1,r4,#1
0000a4  0089              LSLS     r1,r1,#2
0000a6  1809              ADDS     r1,r1,r0
0000a8  3180              ADDS     r1,r1,#0x80
0000aa  6c8d              LDR      r5,[r1,#0x48]
0000ac  2603              MOVS     r6,#3
0000ae  04b6              LSLS     r6,r6,#18
0000b0  43b5              BICS     r5,r5,r6
0000b2  648d              STR      r5,[r1,#0x48]
;;;400                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((2UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
0000b4  6c8d              LDR      r5,[r1,#0x48]
0000b6  2601              MOVS     r6,#1
0000b8  04f6              LSLS     r6,r6,#19
                  |L31.186|
0000ba  4335              ORRS     r5,r5,r6              ;394
                  |L31.188|
0000bc  648d              STR      r5,[r1,#0x48]         ;394
                  |L31.190|
0000be  1c64              ADDS     r4,r4,#1              ;394
0000c0  2c06              CMP      r4,#6                 ;355
0000c2  d3a3              BCC      |L31.12|
;;;401                }
;;;402            }
;;;403        }
;;;404    
;;;405    }
0000c4  bdf0              POP      {r4-r7,pc}
                  |L31.198|
0000c6  0861              LSRS     r1,r4,#1              ;393
0000c8  0089              LSLS     r1,r1,#2              ;393
0000ca  1809              ADDS     r1,r1,r0              ;393
0000cc  3180              ADDS     r1,r1,#0x80           ;393
0000ce  6c8d              LDR      r5,[r1,#0x48]         ;393
0000d0  4395              BICS     r5,r5,r2              ;393
0000d2  648d              STR      r5,[r1,#0x48]         ;393
0000d4  6c8d              LDR      r5,[r1,#0x48]         ;394
0000d6  2601              MOVS     r6,#1                 ;394
0000d8  0476              LSLS     r6,r6,#17             ;394
0000da  e7ee              B        |L31.186|
;;;406    
                          ENDP

                  |L31.220|
                          DCD      0x00008001

                          AREA ||i.PWM_EnableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableFaultBrakeInt PROC
;;;677     */
;;;678    void PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;679    {
;;;680        (pwm)->INTEN1 |= (0x7 << u32BrakeSource);
000002  6e42              LDR      r2,[r0,#0x64]
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6642              STR      r2,[r0,#0x64]
;;;681    }
00000c  4770              BX       lr
;;;682    
                          ENDP


                          AREA ||i.PWM_EnableLoadMode||, CODE, READONLY, ALIGN=1

                  PWM_EnableLoadMode PROC
;;;644     */
;;;645    void PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;646    {
;;;647        (pwm)->CTL0 |= (u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4313              ORRS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;648    }
000008  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;448     */
;;;449    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  3080              ADDS     r0,r0,#0x80
;;;450    {
;;;451        (pwm)->POEN |= u32ChannelMask;
000002  6d82              LDR      r2,[r0,#0x58]
000004  430a              ORRS     r2,r2,r1
000006  6582              STR      r2,[r0,#0x58]
;;;452    }
000008  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.PWM_EnablePDMA||, CODE, READONLY, ALIGN=1

                  PWM_EnablePDMA PROC
;;;996     */
;;;997    void PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;998    {
;;;999        uint32_t u32IsOddCh;
;;;1000       u32IsOddCh = u32ChannelNum % 2;
000002  30ff              ADDS     r0,r0,#0xff
000004  07cc              LSLS     r4,r1,#31
000006  30ff              ADDS     r0,r0,#0xff
000008  3002              ADDS     r0,#2
;;;1001       (pwm)->PDMACTL = ((pwm)->PDMACTL & ~((PWM_PDMACTL_CHSEL0_1_Msk | PWM_PDMACTL_CAPORD0_1_Msk | PWM_PDMACTL_CAPMOD0_1_Msk) << ((u32ChannelNum >> 1) * 8))) | \
00000a  6bc5              LDR      r5,[r0,#0x3c]
00000c  0849              LSRS     r1,r1,#1
00000e  00c9              LSLS     r1,r1,#3
000010  261e              MOVS     r6,#0x1e
000012  408e              LSLS     r6,r6,r1
000014  0ee4              LSRS     r4,r4,#27
000016  00d2              LSLS     r2,r2,#3
000018  4314              ORRS     r4,r4,r2
00001a  431c              ORRS     r4,r4,r3
00001c  2201              MOVS     r2,#1
00001e  4314              ORRS     r4,r4,r2
000020  43b5              BICS     r5,r5,r6
000022  408c              LSLS     r4,r4,r1
000024  4325              ORRS     r5,r5,r4
000026  63c5              STR      r5,[r0,#0x3c]
;;;1002                        (((u32IsOddCh << PWM_PDMACTL_CHSEL0_1_Pos) | (u32RisingFirst << PWM_PDMACTL_CAPORD0_1_Pos) | \
;;;1003                          u32Mode | PWM_PDMACTL_CHEN0_1_Msk) << ((u32ChannelNum >> 1) * 8));
;;;1004   }
000028  bd70              POP      {r4-r6,pc}
;;;1005   
                          ENDP


                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;739     */
;;;740    void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  3080              ADDS     r0,r0,#0x80
;;;741    {
;;;742        (void) u32IntPeriodType;
;;;743        (pwm)->INTEN0 |= (PWM_INTEN0_PIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4099              LSLS     r1,r1,r3
00000e  430a              ORRS     r2,r2,r1
000010  6602              STR      r2,[r0,#0x60]
;;;744    }
000012  4770              BX       lr
;;;745    
                          ENDP


                          AREA ||i.PWM_EnableZeroInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableZeroInt PROC
;;;798     */
;;;799    void PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;800    {
;;;801        (pwm)->INTEN0 |= (PWM_INTEN0_ZIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  430a              ORRS     r2,r2,r1
00000e  6602              STR      r2,[r0,#0x60]
;;;802    }
000010  4770              BX       lr
;;;803    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;231     */
;;;232    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;233    {
;;;234        uint32_t i;
;;;235    
;;;236        for (i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;237        {
;;;238            if (u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
                  |L38.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L38.28|
;;;239            {
;;;240                (pwm)->CNTEN &= ~(1UL << ((i >> 1) << 1));
00000e  6a04              LDR      r4,[r0,#0x20]
000010  0856              LSRS     r6,r2,#1
000012  0076              LSLS     r6,r6,#1
000014  462b              MOV      r3,r5
000016  40b3              LSLS     r3,r3,r6
000018  439c              BICS     r4,r4,r3
00001a  6204              STR      r4,[r0,#0x20]
                  |L38.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a06              CMP      r2,#6                 ;236
000020  d3f1              BCC      |L38.6|
;;;241            }
;;;242        }
;;;243    }
000022  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP


                          AREA ||i.PWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetADCTriggerFlag PROC
;;;322     */
;;;323    uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;324    {
000002  3001              ADDS     r0,#1
;;;325        return (((pwm)->STATUS & (PWM_STATUS_ADCTRG0_Msk << u32ChannelNum)) ? 1 : 0);
000004  6a00              LDR      r0,[r0,#0x20]
000006  2201              MOVS     r2,#1
000008  0412              LSLS     r2,r2,#16
00000a  408a              LSLS     r2,r2,r1
00000c  4010              ANDS     r0,r0,r2
00000e  d000              BEQ      |L39.18|
000010  2001              MOVS     r0,#1
                  |L39.18|
;;;326    }
000012  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;566     */
;;;567    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;568    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;569        return (((((pwm)->CAPIF & (PWM_CAPIF_CFLIF0_Msk << u32ChannelNum)) ? 1 : 0) << 1) | \
000006  4602              MOV      r2,r0
000008  6d40              LDR      r0,[r0,#0x54]
00000a  23ff              MOVS     r3,#0xff
00000c  3301              ADDS     r3,#1
00000e  408b              LSLS     r3,r3,r1
000010  4018              ANDS     r0,r0,r3
000012  d000              BEQ      |L40.22|
000014  2001              MOVS     r0,#1
                  |L40.22|
000016  6d52              LDR      r2,[r2,#0x54]
000018  0040              LSLS     r0,r0,#1
00001a  2301              MOVS     r3,#1
00001c  408b              LSLS     r3,r3,r1
00001e  421a              TST      r2,r3
000020  d001              BEQ      |L40.38|
;;;570                (((pwm)->CAPIF & (PWM_CAPIF_CRLIF0_Msk << u32ChannelNum)) ? 1 : 0));
000022  2101              MOVS     r1,#1
000024  e000              B        |L40.40|
                  |L40.38|
000026  2100              MOVS     r1,#0
                  |L40.40|
000028  4308              ORRS     r0,r0,r1
;;;571    }
00002a  4770              BX       lr
;;;572    /**
                          ENDP


                          AREA ||i.PWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetDutyIntFlag PROC
;;;627     */
;;;628    uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;629    {
;;;630        return ((((pwm)->INTSTS0 & ((PWM_INTSTS0_CMPDIF0_Msk | PWM_INTSTS0_CMPUIF0_Msk) << u32ChannelNum))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  4a02              LDR      r2,|L41.16|
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L41.14|
00000c  2001              MOVS     r0,#1
                  |L41.14|
;;;631    }
00000e  4770              BX       lr
;;;632    
                          ENDP

                  |L41.16|
                          DCD      0x01010000

                          AREA ||i.PWM_GetFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetFaultBrakeIntFlag PROC
;;;724     */
;;;725    uint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;726    {
;;;727        return (((pwm)->INTSTS1 & (0x3f << u32BrakeSource)) ? 1 : 0);
000002  6ec0              LDR      r0,[r0,#0x6c]
000004  223f              MOVS     r2,#0x3f
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L42.14|
00000c  2001              MOVS     r0,#1
                  |L42.14|
;;;728    }
00000e  4770              BX       lr
;;;729    
                          ENDP


                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetPeriodIntFlag PROC
;;;784     */
;;;785    uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;786    {
;;;787        return (((pwm)->INTSTS0 & (PWM_INTSTS0_PIF0_Msk << ((u32ChannelNum >> 1) << 1))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  084a              LSRS     r2,r1,#1
000006  0052              LSLS     r2,r2,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4091              LSLS     r1,r1,r2
00000e  4008              ANDS     r0,r0,r1
000010  d000              BEQ      |L43.20|
000012  2001              MOVS     r0,#1
                  |L43.20|
;;;788    }
000014  4770              BX       lr
;;;789    
                          ENDP


                          AREA ||i.PWM_GetWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetWrapAroundFlag PROC
;;;962     */
;;;963    uint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;964    {
000002  3001              ADDS     r0,#1
;;;965        return (((pwm)->STATUS & (PWM_STATUS_CNTMAX0_Msk << ((u32ChannelNum >> 1) << 1))) ? 1 : 0);
000004  6a00              LDR      r0,[r0,#0x20]
000006  084a              LSRS     r2,r1,#1
000008  0052              LSLS     r2,r2,#1
00000a  2101              MOVS     r1,#1
00000c  4091              LSLS     r1,r1,r2
00000e  4008              ANDS     r0,r0,r1
000010  d000              BEQ      |L44.20|
000012  2001              MOVS     r0,#1
                  |L44.20|
;;;966    }
000014  4770              BX       lr
;;;967    
                          ENDP


                          AREA ||i.PWM_GetZeroIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetZeroIntFlag PROC
;;;842     */
;;;843    uint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;844    {
;;;845        return (((pwm)->INTSTS0 & (PWM_INTSTS0_ZIF0_Msk << ((u32ChannelNum >> 1) << 1))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  084a              LSRS     r2,r1,#1
000006  0052              LSLS     r2,r2,#1
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  4008              ANDS     r0,r0,r1
00000e  d000              BEQ      |L45.18|
000010  2001              MOVS     r0,#1
                  |L45.18|
;;;846    }
000012  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.PWM_SetBrakePinSource||, CODE, READONLY, ALIGN=1

                  PWM_SetBrakePinSource PROC
;;;946     */
;;;947    void PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule)
000000  b510              PUSH     {r4,lr}
;;;948    {
000002  3080              ADDS     r0,r0,#0x80
;;;949        (pwm)->BNF = ((pwm)->BNF & ~(PWM_BNF_BK0SRC_Msk << (u32BrakePinNum * 8))) | (u32SelAnotherModule << (PWM_BNF_BK0SRC_Pos + u32BrakePinNum * 8));
000004  6c03              LDR      r3,[r0,#0x40]
000006  00c9              LSLS     r1,r1,#3
000008  2401              MOVS     r4,#1
00000a  0424              LSLS     r4,r4,#16
00000c  408c              LSLS     r4,r4,r1
00000e  3110              ADDS     r1,r1,#0x10
000010  43a3              BICS     r3,r3,r4
000012  408a              LSLS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  6403              STR      r3,[r0,#0x40]
;;;950    }
000018  bd10              POP      {r4,pc}
;;;951    
                          ENDP


                          AREA ||i.PWM_SetClockSource||, CODE, READONLY, ALIGN=1

                  PWM_SetClockSource PROC
;;;863     */
;;;864    void PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel)
000000  b510              PUSH     {r4,lr}
;;;865    {
;;;866        (pwm)->CLKSRC = ((pwm)->CLKSRC & ~(PWM_CLKSRC_ECLKSRC0_Msk << ((u32ChannelNum >> 1) * PWM_CLKSRC_ECLKSRC2_Pos))) | \
000002  6903              LDR      r3,[r0,#0x10]
000004  0849              LSRS     r1,r1,#1
000006  00c9              LSLS     r1,r1,#3
000008  2407              MOVS     r4,#7
00000a  408c              LSLS     r4,r4,r1
00000c  43a3              BICS     r3,r3,r4
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6103              STR      r3,[r0,#0x10]
;;;867                        (u32ClkSrcSel << ((u32ChannelNum >> 1) * PWM_CLKSRC_ECLKSRC2_Pos));
;;;868    }
000014  bd10              POP      {r4,pc}
;;;869    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;185     */
;;;186    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;187    {
;;;188        uint32_t i;
;;;189    
;;;190        for (i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;191        {
;;;192            if (u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
                  |L48.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L48.28|
;;;193            {
;;;194                (pwm)->CNTEN |= (1UL << ((i >> 1) << 1));
00000e  6a04              LDR      r4,[r0,#0x20]
000010  0856              LSRS     r6,r2,#1
000012  0076              LSLS     r6,r6,#1
000014  462b              MOV      r3,r5
000016  40b3              LSLS     r3,r3,r6
000018  431c              ORRS     r4,r4,r3
00001a  6204              STR      r4,[r0,#0x20]
                  |L48.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a06              CMP      r2,#6                 ;190
000020  d3f1              BCC      |L48.6|
;;;195            }
;;;196        }
;;;197    }
000022  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;208     */
;;;209    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;210    {
;;;211        uint32_t i;
;;;212    
;;;213        for (i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;214        {
;;;215            if (u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L49.8|
000008  462b              MOV      r3,r5
00000a  4093              LSLS     r3,r3,r2
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L49.24|
;;;216            {
;;;217                (pwm)->PERIOD[((i >> 1) << 1)] = 0;
000010  0853              LSRS     r3,r2,#1
000012  00db              LSLS     r3,r3,#3
000014  181b              ADDS     r3,r3,r0
000016  631c              STR      r4,[r3,#0x30]
                  |L49.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a06              CMP      r2,#6                 ;213
00001c  d3f4              BCC      |L49.8|
;;;218            }
;;;219        }
;;;220    }
00001e  bd30              POP      {r4,r5,pc}
;;;221    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 479
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
