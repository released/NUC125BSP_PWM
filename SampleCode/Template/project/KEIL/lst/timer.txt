; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\timer.crf ..\..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;74       */
;;;75     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;76     {
;;;77         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;78         timer->EXTCTL = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;79     }
000006  4770              BX       lr
;;;80     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;93       */
;;;94     void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5f8              PUSH     {r3-r7,lr}
;;;95     {
000002  460c              MOV      r4,r1
000004  4607              MOV      r7,r0
;;;96         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4605              MOV      r5,r0
;;;97         uint32_t u32Prescale = 0, u32Delay = (SystemCoreClock / u32Clk) + 1;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4829              LDR      r0,|L2.184|
000012  4629              MOV      r1,r5
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1c46              ADDS     r6,r0,#1
;;;98         uint32_t u32Cmpr, u32NsecPerTick;
;;;99     
;;;100        // Clear current timer configuration/
;;;101        timer->CTL = 0;
00001c  2000              MOVS     r0,#0
00001e  6038              STR      r0,[r7,#0]
;;;102        timer->EXTCTL = 0;
000020  6178              STR      r0,[r7,#0x14]
;;;103    
;;;104        if (u32Clk <= 1000000)   // min delay is 1000 us if timer clock source is <= 1 MHz
000022  4926              LDR      r1,|L2.188|
000024  428d              CMP      r5,r1
000026  d805              BHI      |L2.52|
;;;105        {
;;;106            if (u32Usec < 1000)
000028  207d              MOVS     r0,#0x7d
00002a  00c0              LSLS     r0,r0,#3
00002c  4284              CMP      r4,r0
00002e  d205              BCS      |L2.60|
;;;107                u32Usec = 1000;
000030  4604              MOV      r4,r0
000032  e006              B        |L2.66|
                  |L2.52|
;;;108    
;;;109            if (u32Usec > 1000000)
;;;110                u32Usec = 1000000;
;;;111        }
;;;112        else
;;;113        {
;;;114            if (u32Usec < 100)
000034  2c64              CMP      r4,#0x64
000036  d201              BCS      |L2.60|
;;;115                u32Usec = 100;
000038  2464              MOVS     r4,#0x64
00003a  e002              B        |L2.66|
                  |L2.60|
;;;116    
;;;117            if (u32Usec > 1000000)
00003c  428c              CMP      r4,r1
00003e  d900              BLS      |L2.66|
;;;118                u32Usec = 1000000;
000040  460c              MOV      r4,r1
                  |L2.66|
;;;119        }
;;;120    
;;;121        if (u32Clk <= 1000000)
000042  428d              CMP      r5,r1
000044  d808              BHI      |L2.88|
                  |L2.70|
;;;122        {
;;;123            u32Prescale = 0;
;;;124            u32NsecPerTick = 1000000000 / u32Clk;
000046  4629              MOV      r1,r5
000048  481d              LDR      r0,|L2.192|
00004a  f7fffffe          BL       __aeabi_uidivmod
00004e  4601              MOV      r1,r0
;;;125            u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
000050  207d              MOVS     r0,#0x7d
000052  00c0              LSLS     r0,r0,#3
000054  4360              MULS     r0,r4,r0
000056  e017              B        |L2.136|
                  |L2.88|
;;;126        }
;;;127        else
;;;128        {
;;;129            if (u32Clk > 64000000)
000058  481a              LDR      r0,|L2.196|
00005a  4285              CMP      r5,r0
00005c  d903              BLS      |L2.102|
;;;130            {
;;;131                u32Prescale = 7;    // real prescaler value is 8
00005e  2007              MOVS     r0,#7
;;;132                u32Clk >>= 3;
000060  08ed              LSRS     r5,r5,#3
000062  9000              STR      r0,[sp,#0]
000064  e00c              B        |L2.128|
                  |L2.102|
;;;133            }
;;;134            else if (u32Clk > 32000000)
000066  4818              LDR      r0,|L2.200|
000068  4285              CMP      r5,r0
00006a  d903              BLS      |L2.116|
;;;135            {
;;;136                u32Prescale = 3;    // real prescaler value is 4
00006c  2003              MOVS     r0,#3
;;;137                u32Clk >>= 2;
00006e  08ad              LSRS     r5,r5,#2
000070  9000              STR      r0,[sp,#0]
000072  e005              B        |L2.128|
                  |L2.116|
;;;138            }
;;;139            else if (u32Clk > 16000000)
000074  4815              LDR      r0,|L2.204|
000076  4285              CMP      r5,r0
000078  d902              BLS      |L2.128|
;;;140            {
;;;141                u32Prescale = 1;    // real prescaler value is 2
00007a  2001              MOVS     r0,#1
;;;142                u32Clk >>= 1;
00007c  086d              LSRS     r5,r5,#1
00007e  9000              STR      r0,[sp,#0]
                  |L2.128|
;;;143            }
;;;144    
;;;145            if (u32Usec < 250)
000080  2cfa              CMP      r4,#0xfa
000082  d212              BCS      |L2.170|
000084  4620              MOV      r0,r4
;;;146            {
;;;147                u32Cmpr = (u32Usec * u32Clk) / 1000000;
000086  4368              MULS     r0,r5,r0
                  |L2.136|
;;;148            }
;;;149            else if (u32Clk % 1000000 == 0)
;;;150            {
;;;151                u32Cmpr = (u32Clk / 1000000) * u32Usec;
;;;152            }
;;;153            else
;;;154            {
;;;155                u32NsecPerTick = 1000000000 / u32Clk;
;;;156                u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
000088  f7fffffe          BL       __aeabi_uidivmod
                  |L2.140|
;;;157            }
;;;158        }
;;;159    
;;;160        timer->CMP = u32Cmpr;
00008c  6078              STR      r0,[r7,#4]
;;;161        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
00008e  2101              MOVS     r1,#1
000090  9800              LDR      r0,[sp,#0]
000092  0789              LSLS     r1,r1,#30
000094  4308              ORRS     r0,r0,r1
000096  6038              STR      r0,[r7,#0]
;;;162    
;;;163        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;164        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;165        for (; u32Delay > 0; u32Delay--)
000098  2e00              CMP      r6,#0
00009a  d002              BEQ      |L2.162|
                  |L2.156|
;;;166        {
;;;167            __NOP();
00009c  bf00              NOP      
00009e  1e76              SUBS     r6,r6,#1
0000a0  d1fc              BNE      |L2.156|
                  |L2.162|
;;;168        }
;;;169    
;;;170        while (timer->CTL & TIMER_CTL_ACTSTS_Msk);
0000a2  6838              LDR      r0,[r7,#0]
0000a4  0180              LSLS     r0,r0,#6
0000a6  d4fc              BMI      |L2.162|
;;;171    }
0000a8  bdf8              POP      {r3-r7,pc}
                  |L2.170|
0000aa  4628              MOV      r0,r5                 ;149
0000ac  f7fffffe          BL       __aeabi_uidivmod
0000b0  2900              CMP      r1,#0                 ;149
0000b2  d1c8              BNE      |L2.70|
0000b4  4360              MULS     r0,r4,r0              ;151
0000b6  e7e9              B        |L2.140|
;;;172    
                          ENDP

                  |L2.184|
                          DCD      SystemCoreClock
                  |L2.188|
                          DCD      0x000f4240
                  |L2.192|
                          DCD      0x3b9aca00
                  |L2.196|
                          DCD      0x03d09000
                  |L2.200|
                          DCD      0x01e84800
                  |L2.204|
                          DCD      0x00f42400

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;206      */
;;;207    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;208    {
;;;209        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;210    }
000008  4770              BX       lr
;;;211    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;240      */
;;;241    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;242    {
;;;243        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;244    }
00000a  4770              BX       lr
;;;245    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;190      */
;;;191    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193    
;;;194        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  6943              LDR      r3,[r0,#0x14]
000004  2416              MOVS     r4,#0x16
000006  43a3              BICS     r3,r3,r4
000008  430b              ORRS     r3,r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6143              STR      r3,[r0,#0x14]
;;;195                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;196    }
000012  bd10              POP      {r4,pc}
;;;197    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;225      */
;;;226    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;227    {
;;;228        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;229        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  0612              LSLS     r2,r2,#24
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;230    }
000014  4770              BX       lr
;;;231    
                          ENDP


                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;255      */
;;;256    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;257    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;258        uint32_t u32Src, u32Clk;
;;;259        const uint32_t au32Clk[] = {__HXT, __LXT, 0, 0, 0, __LIRC, 0, __HIRC_DIV2};
000006  2220              MOVS     r2,#0x20
000008  4919              LDR      r1,|L7.112|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;260    
;;;261        if (timer == TIMER0)
;;;262            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
;;;263        else if (timer == TIMER1)
000010  4b18              LDR      r3,|L7.116|
000012  4a18              LDR      r2,|L7.116|
000014  4818              LDR      r0,|L7.120|
000016  3320              ADDS     r3,r3,#0x20
000018  4294              CMP      r4,r2                 ;261
00001a  d102              BNE      |L7.34|
00001c  6940              LDR      r0,[r0,#0x14]         ;262
;;;264            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
;;;265        else if (timer == TIMER2)
;;;266            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
;;;267        else if (timer == TIMER3)
;;;268            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
;;;269        else
;;;270            return 0;
;;;271    
;;;272        if (u32Src == 2)
;;;273        {
;;;274            if ((timer == TIMER0) || (timer == TIMER1))
;;;275            {
;;;276                u32Clk = CLK_GetPCLK0Freq();
;;;277            }
;;;278            else
;;;279            {
;;;280                u32Clk = CLK_GetPCLK1Freq();
;;;281            }
;;;282        }
;;;283        else
;;;284        {
;;;285            u32Clk = au32Clk[u32Src];
;;;286        }
;;;287    
;;;288        return u32Clk;
;;;289    }
00001e  0a00              LSRS     r0,r0,#8
000020  e010              B        |L7.68|
                  |L7.34|
000022  429c              CMP      r4,r3                 ;263
000024  d102              BNE      |L7.44|
000026  6940              LDR      r0,[r0,#0x14]         ;264
000028  0b00              LSRS     r0,r0,#12
00002a  e00b              B        |L7.68|
                  |L7.44|
00002c  4913              LDR      r1,|L7.124|
00002e  428c              CMP      r4,r1                 ;265
000030  d102              BNE      |L7.56|
000032  6940              LDR      r0,[r0,#0x14]         ;266
000034  0c00              LSRS     r0,r0,#16
000036  e005              B        |L7.68|
                  |L7.56|
000038  4910              LDR      r1,|L7.124|
00003a  3120              ADDS     r1,r1,#0x20           ;267
00003c  428c              CMP      r4,r1                 ;267
00003e  d10a              BNE      |L7.86|
000040  6940              LDR      r0,[r0,#0x14]         ;268
000042  0d00              LSRS     r0,r0,#20
                  |L7.68|
000044  0741              LSLS     r1,r0,#29
000046  0f49              LSRS     r1,r1,#29
000048  2902              CMP      r1,#2                 ;272
00004a  d006              BEQ      |L7.90|
00004c  0088              LSLS     r0,r1,#2              ;285
00004e  4669              MOV      r1,sp                 ;285
000050  5808              LDR      r0,[r1,r0]            ;285
                  |L7.82|
000052  b008              ADD      sp,sp,#0x20
000054  bd10              POP      {r4,pc}
                  |L7.86|
000056  2000              MOVS     r0,#0                 ;270
000058  e7fb              B        |L7.82|
                  |L7.90|
00005a  4294              CMP      r4,r2                 ;274
00005c  d001              BEQ      |L7.98|
00005e  429c              CMP      r4,r3                 ;274
000060  d102              BNE      |L7.104|
                  |L7.98|
000062  f7fffffe          BL       CLK_GetPCLK0Freq
000066  e7f4              B        |L7.82|
                  |L7.104|
000068  f7fffffe          BL       CLK_GetPCLK1Freq
00006c  e7f1              B        |L7.82|
;;;290    
                          ENDP

00006e  0000              DCW      0x0000
                  |L7.112|
                          DCD      ||.constdata||
                  |L7.116|
                          DCD      0x40010000
                  |L7.120|
                          DCD      0x50000200
                  |L7.124|
                          DCD      0x40110000

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;40       */
;;;41     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;42     {
000002  4617              MOV      r7,r2
000004  4606              MOV      r6,r0
;;;43         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4605              MOV      r5,r0
;;;44         uint32_t u32Cmpr = 0UL, u32Prescale = 0UL;
00000c  2400              MOVS     r4,#0
;;;45     
;;;46         /* Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, prescaler = 0. */
;;;47         if (u32Freq > (u32Clk / 2UL))
00000e  0840              LSRS     r0,r0,#1
000010  42b8              CMP      r0,r7
000012  d201              BCS      |L8.24|
;;;48         {
;;;49             u32Cmpr = 2UL;
000014  2002              MOVS     r0,#2
000016  e008              B        |L8.42|
                  |L8.24|
;;;50         }
;;;51         else
;;;52         {
;;;53             u32Cmpr = u32Clk / u32Freq;
000018  4639              MOV      r1,r7
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       __aeabi_uidivmod
;;;54             u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
000020  0e04              LSRS     r4,r0,#24
;;;55     
;;;56             if (u32Prescale > 0UL)
000022  d002              BEQ      |L8.42|
;;;57                 u32Cmpr = u32Cmpr / (u32Prescale + 1UL);
000024  1c61              ADDS     r1,r4,#1
000026  f7fffffe          BL       __aeabi_uidivmod
                  |L8.42|
;;;58         }
;;;59     
;;;60         timer->CTL = u32Mode | u32Prescale;
00002a  9901              LDR      r1,[sp,#4]
00002c  4321              ORRS     r1,r1,r4
00002e  6031              STR      r1,[r6,#0]
;;;61         timer->CMP = u32Cmpr;
000030  6070              STR      r0,[r6,#4]
000032  1c64              ADDS     r4,r4,#1
;;;62     
;;;63         return (u32Clk / (u32Cmpr * (u32Prescale + 1UL)));
000034  4360              MULS     r0,r4,r0
000036  4601              MOV      r1,r0
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       __aeabi_uidivmod
;;;64     }
00003e  bdfe              POP      {r1-r7,pc}
;;;65     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x016e3600

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 479
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
